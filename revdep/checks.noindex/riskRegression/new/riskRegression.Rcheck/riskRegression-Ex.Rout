
R version 4.0.0 (2020-04-24) -- "Arbor Day"
Copyright (C) 2020 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin17.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "riskRegression"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('riskRegression')
riskRegression version 2020.02.05
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("CSC")
> ### * CSC
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: CSC
> ### Title: Cause-specific Cox proportional hazard regression
> ### Aliases: CSC
> ### Keywords: survival
> 
> ### ** Examples
> 
> 
> library(prodlim)
> library(survival)
> data(Melanoma)
> ## fit two cause-specific Cox models
> ## different formula for the two causes
> fit1 <- CSC(list(Hist(time,status)~sex+age,Hist(time,status)~invasion+epicel+log(thick)),
+             data=Melanoma)
> print(fit1)
CSC(formula = list(Hist(time, status) ~ sex + age, Hist(time, 
    status) ~ invasion + epicel + log(thick)), data = Melanoma)

Right-censored response of a competing.risks model

No.Observations: 205 

Pattern:
         
Cause     event right.censored
  1          57              0
  2          14              0
  unknown     0            134


----------> Cause:  1 

Call:
survival::coxph(formula = survival::Surv(time, status) ~ sex + 
    age, x = TRUE, y = TRUE)

  n= 205, number of events= 57 

            coef exp(coef) se(coef)     z Pr(>|z|)  
sexMale 0.598259  1.818949 0.267639 2.235   0.0254 *
age     0.016542  1.016679 0.008663 1.910   0.0562 .
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

        exp(coef) exp(-coef) lower .95 upper .95
sexMale     1.819     0.5498    1.0765     3.074
age         1.017     0.9836    0.9996     1.034

Concordance= 0.631  (se = 0.037 )
Likelihood ratio test= 9.94  on 2 df,   p=0.007
Wald test            = 10  on 2 df,   p=0.007
Score (logrank) test = 10.26  on 2 df,   p=0.006



----------> Cause:  2 

Call:
survival::coxph(formula = survival::Surv(time, status) ~ invasion + 
    epicel + log(thick), x = TRUE, y = TRUE)

  n= 205, number of events= 14 

                   coef exp(coef) se(coef)      z Pr(>|z|)  
invasionlevel.1 -0.7315    0.4812   0.6492 -1.127   0.2599  
invasionlevel.2 -2.2593    0.1044   1.2478 -1.811   0.0702 .
epicelpresent    1.0840    2.9564   0.5738  1.889   0.0589 .
log(thick)       0.8954    2.4484   0.3959  2.262   0.0237 *
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

                exp(coef) exp(-coef) lower .95 upper .95
invasionlevel.1    0.4812     2.0781  0.134806     1.718
invasionlevel.2    0.1044     9.5768  0.009051     1.205
epicelpresent      2.9564     0.3383  0.960134     9.103
log(thick)         2.4484     0.4084  1.126881     5.320

Concordance= 0.648  (se = 0.1 )
Likelihood ratio test= 7.41  on 4 df,   p=0.1
Wald test            = 7.72  on 4 df,   p=0.1
Score (logrank) test = 7.44  on 4 df,   p=0.1

> ## Not run: 
> ##D library(Publish)
> ##D publish(fit1)
> ## End(Not run)
> 
> ## model hazard of all cause mortality instead of hazard of type 2 
> fit1a <- CSC(list(Hist(time,status)~sex+age,Hist(time,status)~invasion+epicel+log(thick)),
+              data=Melanoma,
+              surv.type="surv")
> 
> ## the predicted probabilities are similar 
> plot(predictRisk(fit1,times=500,cause=1,newdata=Melanoma),
+      predictRisk(fit1a,times=500,cause=1,newdata=Melanoma))
> 
> ## special case where cause 2 has no covariates
> fit1b <- CSC(list(Hist(time,status)~sex+age,Hist(time,status)~1),
+              data=Melanoma)
> print(fit1b)
CSC(formula = list(Hist(time, status) ~ sex + age, Hist(time, 
    status) ~ 1), data = Melanoma)

Right-censored response of a competing.risks model

No.Observations: 205 

Pattern:
         
Cause     event right.censored
  1          57              0
  2          14              0
  unknown     0            134


----------> Cause:  1 

Call:
survival::coxph(formula = survival::Surv(time, status) ~ sex + 
    age, x = TRUE, y = TRUE)

  n= 205, number of events= 57 

            coef exp(coef) se(coef)     z Pr(>|z|)  
sexMale 0.598259  1.818949 0.267639 2.235   0.0254 *
age     0.016542  1.016679 0.008663 1.910   0.0562 .
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

        exp(coef) exp(-coef) lower .95 upper .95
sexMale     1.819     0.5498    1.0765     3.074
age         1.017     0.9836    0.9996     1.034

Concordance= 0.631  (se = 0.037 )
Likelihood ratio test= 9.94  on 2 df,   p=0.007
Wald test            = 10  on 2 df,   p=0.007
Score (logrank) test = 10.26  on 2 df,   p=0.006



----------> Cause:  2 

Call:  survival::coxph(formula = survival::Surv(time, status) ~ 1, x = TRUE, 
    y = TRUE)

Null model
  log likelihood= -67.29348 
  n= 205 
> predict(fit1b,cause=1,times=100,newdata=Melanoma)
     observation    sex age times absRisk
  1:           1   Male  76   100       0
  2:           2   Male  56   100       0
  3:           3   Male  41   100       0
  4:           4 Female  71   100       0
  5:           5   Male  52   100       0
 ---                                     
201:         201   Male  29   100       0
202:         202 Female  40   100       0
203:         203 Female  42   100       0
204:         204 Female  50   100       0
205:         205 Female  41   100       0
> 
> 
> ## same formula for both causes
> fit2 <- CSC(Hist(time,status)~invasion+epicel+age,
+             data=Melanoma)
> print(fit2)
CSC(formula = Hist(time, status) ~ invasion + epicel + age, data = Melanoma)

Right-censored response of a competing.risks model

No.Observations: 205 

Pattern:
         
Cause     event right.censored
  1          57              0
  2          14              0
  unknown     0            134


----------> Cause:  1 

Call:
survival::coxph(formula = survival::Surv(time, status) ~ invasion + 
    epicel + age, x = TRUE, y = TRUE)

  n= 205, number of events= 57 

                     coef exp(coef)  se(coef)      z Pr(>|z|)    
invasionlevel.1  0.935415  2.548270  0.326212  2.868  0.00414 ** 
invasionlevel.2  1.268866  3.556818  0.384273  3.302  0.00096 ***
epicelpresent   -0.824665  0.438382  0.301977 -2.731  0.00632 ** 
age              0.017170  1.017318  0.008795  1.952  0.05092 .  
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

                exp(coef) exp(-coef) lower .95 upper .95
invasionlevel.1    2.5483     0.3924    1.3445    4.8297
invasionlevel.2    3.5568     0.2812    1.6748    7.5536
epicelpresent      0.4384     2.2811    0.2426    0.7923
age                1.0173     0.9830    0.9999    1.0350

Concordance= 0.696  (se = 0.036 )
Likelihood ratio test= 28.72  on 4 df,   p=9e-06
Wald test            = 25.85  on 4 df,   p=3e-05
Score (logrank) test = 28.07  on 4 df,   p=1e-05



----------> Cause:  2 

Call:
survival::coxph(formula = survival::Surv(time, status) ~ invasion + 
    epicel + age, x = TRUE, y = TRUE)

  n= 205, number of events= 14 

                    coef exp(coef) se(coef)      z Pr(>|z|)    
invasionlevel.1 -0.91300   0.40132  0.64105 -1.424 0.154381    
invasionlevel.2 -1.27662   0.27898  1.11701 -1.143 0.253086    
epicelpresent    0.32241   1.38045  0.57013  0.566 0.571730    
age              0.09323   1.09772  0.02605  3.579 0.000346 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

                exp(coef) exp(-coef) lower .95 upper .95
invasionlevel.1    0.4013     2.4918   0.11424     1.410
invasionlevel.2    0.2790     3.5845   0.03124     2.491
epicelpresent      1.3804     0.7244   0.45157     4.220
age                1.0977     0.9110   1.04307     1.155

Concordance= 0.83  (se = 0.046 )
Likelihood ratio test= 18.99  on 4 df,   p=8e-04
Wald test            = 14  on 4 df,   p=0.007
Score (logrank) test = 15.03  on 4 df,   p=0.005

> 
> ## combine a cause-specific Cox regression model for cause 2 
> ## and a Cox regression model for the event-free survival:
> ## different formula for cause 2 and event-free survival
> fit3 <- CSC(list(Hist(time,status)~sex+invasion+epicel+age,
+                  Hist(time,status)~invasion+epicel+age),
+             surv.type="surv",
+             data=Melanoma)
> print(fit3)
CSC(formula = list(Hist(time, status) ~ sex + invasion + epicel + 
    age, Hist(time, status) ~ invasion + epicel + age), data = Melanoma, 
    surv.type = "surv")

Right-censored response of a competing.risks model

No.Observations: 205 

Pattern:
         
Cause     event right.censored
  1          57              0
  2          14              0
  unknown     0            134


----------> Cause:  1 

Call:
survival::coxph(formula = survival::Surv(time, status) ~ sex + 
    invasion + epicel + age, x = TRUE, y = TRUE)

  n= 205, number of events= 57 

                    coef exp(coef) se(coef)      z Pr(>|z|)    
sexMale          0.81455   2.25817  0.27080  3.008 0.002630 ** 
invasionlevel.1  0.95491   2.59842  0.32593  2.930 0.003392 ** 
invasionlevel.2  1.37028   3.93647  0.38333  3.575 0.000351 ***
epicelpresent   -0.96361   0.38151  0.30587 -3.150 0.001630 ** 
age              0.01624   1.01637  0.00844  1.924 0.054392 .  
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

                exp(coef) exp(-coef) lower .95 upper .95
sexMale            2.2582     0.4428    1.3282    3.8394
invasionlevel.1    2.5984     0.3848    1.3718    4.9220
invasionlevel.2    3.9365     0.2540    1.8570    8.3445
epicelpresent      0.3815     2.6211    0.2095    0.6948
age                1.0164     0.9839    0.9997    1.0333

Concordance= 0.731  (se = 0.036 )
Likelihood ratio test= 37.59  on 5 df,   p=5e-07
Wald test            = 33.68  on 5 df,   p=3e-06
Score (logrank) test = 35.94  on 5 df,   p=1e-06



----------> Event-free survival:

Call:
survival::coxph(formula = survival::Surv(time, status) ~ invasion + 
    epicel + age, x = TRUE, y = TRUE)

  n= 205, number of events= 71 

                     coef exp(coef)  se(coef)      z Pr(>|z|)   
invasionlevel.1  0.598823  1.819976  0.280176  2.137  0.03257 * 
invasionlevel.2  0.846287  2.330977  0.345425  2.450  0.01429 * 
epicelpresent   -0.573750  0.563408  0.254760 -2.252  0.02431 * 
age              0.027346  1.027723  0.008348  3.276  0.00105 **
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

                exp(coef) exp(-coef) lower .95 upper .95
invasionlevel.1    1.8200     0.5495     1.051    3.1517
invasionlevel.2    2.3310     0.4290     1.184    4.5874
epicelpresent      0.5634     1.7749     0.342    0.9283
age                1.0277     0.9730     1.011    1.0447

Concordance= 0.682  (se = 0.032 )
Likelihood ratio test= 27.56  on 4 df,   p=2e-05
Wald test            = 26.15  on 4 df,   p=3e-05
Score (logrank) test = 27.02  on 4 df,   p=2e-05

> 
> ## same formula for both causes
> fit4 <- CSC(Hist(time,status)~invasion+epicel+age,
+             data=Melanoma,
+             surv.type="surv")
> print(fit4)
CSC(formula = Hist(time, status) ~ invasion + epicel + age, data = Melanoma, 
    surv.type = "surv")

Right-censored response of a competing.risks model

No.Observations: 205 

Pattern:
         
Cause     event right.censored
  1          57              0
  2          14              0
  unknown     0            134


----------> Cause:  1 

Call:
survival::coxph(formula = survival::Surv(time, status) ~ invasion + 
    epicel + age, x = TRUE, y = TRUE)

  n= 205, number of events= 57 

                     coef exp(coef)  se(coef)      z Pr(>|z|)    
invasionlevel.1  0.935415  2.548270  0.326212  2.868  0.00414 ** 
invasionlevel.2  1.268866  3.556818  0.384273  3.302  0.00096 ***
epicelpresent   -0.824665  0.438382  0.301977 -2.731  0.00632 ** 
age              0.017170  1.017318  0.008795  1.952  0.05092 .  
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

                exp(coef) exp(-coef) lower .95 upper .95
invasionlevel.1    2.5483     0.3924    1.3445    4.8297
invasionlevel.2    3.5568     0.2812    1.6748    7.5536
epicelpresent      0.4384     2.2811    0.2426    0.7923
age                1.0173     0.9830    0.9999    1.0350

Concordance= 0.696  (se = 0.036 )
Likelihood ratio test= 28.72  on 4 df,   p=9e-06
Wald test            = 25.85  on 4 df,   p=3e-05
Score (logrank) test = 28.07  on 4 df,   p=1e-05



----------> Event-free survival:

Call:
survival::coxph(formula = survival::Surv(time, status) ~ invasion + 
    epicel + age, x = TRUE, y = TRUE)

  n= 205, number of events= 71 

                     coef exp(coef)  se(coef)      z Pr(>|z|)   
invasionlevel.1  0.598823  1.819976  0.280176  2.137  0.03257 * 
invasionlevel.2  0.846287  2.330977  0.345425  2.450  0.01429 * 
epicelpresent   -0.573750  0.563408  0.254760 -2.252  0.02431 * 
age              0.027346  1.027723  0.008348  3.276  0.00105 **
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

                exp(coef) exp(-coef) lower .95 upper .95
invasionlevel.1    1.8200     0.5495     1.051    3.1517
invasionlevel.2    2.3310     0.4290     1.184    4.5874
epicelpresent      0.5634     1.7749     0.342    0.9283
age                1.0277     0.9730     1.011    1.0447

Concordance= 0.682  (se = 0.032 )
Likelihood ratio test= 27.56  on 4 df,   p=2e-05
Wald test            = 26.15  on 4 df,   p=3e-05
Score (logrank) test = 27.02  on 4 df,   p=2e-05

> 
> ## strata
> fit5 <- CSC(Hist(time,status)~invasion+epicel+age+strata(sex),
+             data=Melanoma,
+             surv.type="surv")
> print(fit5)
CSC(formula = Hist(time, status) ~ invasion + epicel + age + 
    strata(sex), data = Melanoma, surv.type = "surv")

Right-censored response of a competing.risks model

No.Observations: 205 

Pattern:
         
Cause     event right.censored
  1          57              0
  2          14              0
  unknown     0            134


----------> Cause:  1 

Call:
survival::coxph(formula = survival::Surv(time, status) ~ invasion + 
    epicel + age + strata(sex), x = TRUE, y = TRUE)

  n= 205, number of events= 57 

                     coef exp(coef)  se(coef)      z Pr(>|z|)    
invasionlevel.1  0.962644  2.618612  0.326103  2.952 0.003158 ** 
invasionlevel.2  1.341972  3.826581  0.385085  3.485 0.000492 ***
epicelpresent   -0.966928  0.380249  0.307215 -3.147 0.001647 ** 
age              0.016206  1.016338  0.008442  1.920 0.054916 .  
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

                exp(coef) exp(-coef) lower .95 upper .95
invasionlevel.1    2.6186     0.3819    1.3819    4.9619
invasionlevel.2    3.8266     0.2613    1.7990    8.1395
epicelpresent      0.3802     2.6299    0.2082    0.6943
age                1.0163     0.9839    0.9997    1.0333

Concordance= 0.716  (se = 0.036 )
Likelihood ratio test= 31.18  on 4 df,   p=3e-06
Wald test            = 27.78  on 4 df,   p=1e-05
Score (logrank) test = 30.19  on 4 df,   p=4e-06



----------> Event-free survival:

Call:
survival::coxph(formula = survival::Surv(time, status) ~ invasion + 
    epicel + age + strata(sex), x = TRUE, y = TRUE)

  n= 205, number of events= 71 

                     coef exp(coef)  se(coef)      z Pr(>|z|)   
invasionlevel.1  0.638422  1.893491  0.280113  2.279  0.02266 * 
invasionlevel.2  0.921428  2.512877  0.347222  2.654  0.00796 **
epicelpresent   -0.699726  0.496721  0.259302 -2.698  0.00697 **
age              0.025606  1.025937  0.008091  3.165  0.00155 **
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

                exp(coef) exp(-coef) lower .95 upper .95
invasionlevel.1    1.8935     0.5281    1.0935    3.2787
invasionlevel.2    2.5129     0.3980    1.2724    4.9628
epicelpresent      0.4967     2.0132    0.2988    0.8257
age                1.0259     0.9747    1.0098    1.0423

Concordance= 0.702  (se = 0.031 )
Likelihood ratio test= 28.77  on 4 df,   p=9e-06
Wald test            = 27.35  on 4 df,   p=2e-05
Score (logrank) test = 28.17  on 4 df,   p=1e-05

> 
> ## sanity checks
> 
> cox1 <- coxph(Surv(time,status==1)~invasion+epicel+age+strata(sex),data=Melanoma)
> cox2 <- coxph(Surv(time,status!=0)~invasion+epicel+age+strata(sex),data=Melanoma)
> all.equal(coef(cox1),coef(fit5$models[[1]]))
[1] TRUE
> all.equal(coef(cox2),coef(fit5$models[[2]]))
[1] TRUE
> 
> ## predictions
> ##
> ## surv.type = "hazard": predictions for both causes can be extracted
> ## from the same fit
> fit2 <- CSC(Hist(time,status)~invasion+epicel+age, data=Melanoma)
> predict(fit2,cause=1,newdata=Melanoma[c(17,99,108),],times=c(100,1000,10000))
   observation invasion      epicel age times absRisk
1:           1  level.1 not present  46   100  0.0000
2:           2  level.1 not present  34   100  0.0000
3:           3  level.0     present  58   100  0.0000
4:           1  level.1 not present  46  1000  0.1928
5:           2  level.1 not present  34  1000  0.1603
6:           3  level.0     present  58  1000  0.0427
7:           1  level.1 not present  46 10000      NA
8:           2  level.1 not present  34 10000      NA
9:           3  level.0     present  58 10000      NA
> predictRisk(fit2,cause=1,newdata=Melanoma[c(17,99,108),],times=c(100,1000,10000))
     [,1]       [,2] [,3]
[1,]    0 0.19283566   NA
[2,]    0 0.16026171   NA
[3,]    0 0.04268555   NA
> predictRisk(fit2,cause=2,newdata=Melanoma[c(17,99,108),],times=c(100,1000,10000))
             [,1]        [,2] [,3]
[1,] 0.0018172532 0.004281110   NA
[2,] 0.0005938955 0.001411264   NA
[3,] 0.0190247785 0.045781785   NA
> predict(fit2,cause=1,newdata=Melanoma[c(17,99,108),],times=c(100,1000,10000))
   observation invasion      epicel age times absRisk
1:           1  level.1 not present  46   100  0.0000
2:           2  level.1 not present  34   100  0.0000
3:           3  level.0     present  58   100  0.0000
4:           1  level.1 not present  46  1000  0.1928
5:           2  level.1 not present  34  1000  0.1603
6:           3  level.0     present  58  1000  0.0427
7:           1  level.1 not present  46 10000      NA
8:           2  level.1 not present  34 10000      NA
9:           3  level.0     present  58 10000      NA
> predict(fit2,cause=2,newdata=Melanoma[c(17,99,108),],times=c(100,1000,10000))
   observation invasion      epicel age times  absRisk
1:           1  level.1 not present  46   100 0.001817
2:           2  level.1 not present  34   100 0.000594
3:           3  level.0     present  58   100 0.019025
4:           1  level.1 not present  46  1000 0.004281
5:           2  level.1 not present  34  1000 0.001411
6:           3  level.0     present  58  1000 0.045782
7:           1  level.1 not present  46 10000       NA
8:           2  level.1 not present  34 10000       NA
9:           3  level.0     present  58 10000       NA
> 
> ## surv.type = "surv" we need to change the cause of interest 
> library(survival)
> fit5.2 <- CSC(Hist(time,status)~invasion+epicel+age+strata(sex),
+             data=Melanoma,
+             surv.type="surv",cause=2)
> ## now this does not work
> try(predictRisk(fit5.2,cause=1,newdata=Melanoma,times=4))
Error in predict.CauseSpecificCox(object = object, newdata = newdata,  : 
  Object can be used to predict cause 2 but not 1.
Note: the cause can be specified in CSC(...,cause=).
> 
> ## but this does
> predictRisk(fit5.2,cause=2,newdata=Melanoma,times=100)
               [,1]
  [1,] 6.024245e-02
  [2,] 1.673423e-02
  [3,] 1.835066e-03
  [4,] 2.895922e-02
  [5,] 4.164144e-03
  [6,] 3.517575e-04
  [7,] 4.226097e-02
  [8,] 2.463623e-03
  [9,] 4.611868e-03
 [10,] 2.191509e-02
 [11,] 2.406810e-03
 [12,] 1.511304e-02
 [13,] 2.191509e-02
 [14,] 1.154850e-02
 [15,] 6.425035e-05
 [16,] 2.659387e-02
 [17,] 2.917383e-03
 [18,] 2.068914e-02
 [19,] 1.724844e-01
 [20,] 3.914382e-03
 [21,] 6.822831e-02
 [22,] 1.200253e-03
 [23,] 1.266319e-03
 [24,] 2.208993e-03
 [25,] 2.239422e-02
 [26,] 2.541578e-02
 [27,] 6.570964e-02
 [28,] 3.180427e-03
 [29,] 7.736975e-05
 [30,] 1.102360e-03
 [31,] 2.110609e-02
 [32,] 5.087808e-03
 [33,] 2.014573e-02
 [34,] 2.956986e-03
 [35,] 1.835710e-02
 [36,] 1.858209e-02
 [37,] 2.383689e-04
 [38,] 1.860938e-02
 [39,] 3.180427e-03
 [40,] 8.437599e-03
 [41,] 3.829844e-03
 [42,] 1.693350e-02
 [43,] 4.705314e-03
 [44,] 4.487192e-02
 [45,] 6.388287e-04
 [46,] 1.034547e-01
 [47,] 2.135234e-02
 [48,] 1.154850e-02
 [49,] 1.354302e-02
 [50,] 6.435496e-02
 [51,] 1.980824e-01
 [52,] 2.595079e-02
 [53,] 2.110609e-02
 [54,] 5.060864e-03
 [55,] 5.634319e-04
 [56,] 3.490063e-03
 [57,] 3.291931e-03
 [58,] 1.644268e-03
 [59,] 4.960533e-04
 [60,] 1.256050e-03
 [61,] 9.505245e-04
 [62,] 1.234149e-02
 [63,] 1.836095e-02
 [64,] 7.887092e-03
 [65,] 6.549697e-03
 [66,] 3.829844e-03
 [67,] 7.543867e-04
 [68,] 2.541578e-02
 [69,] 6.687805e-04
 [70,] 5.348562e-03
 [71,] 7.730730e-04
 [72,] 1.152500e-01
 [73,] 2.898261e-03
 [74,] 3.722244e-04
 [75,] 8.654954e-03
 [76,] 1.754134e-03
 [77,] 5.968612e-03
 [78,] 8.591512e-03
 [79,] 3.149017e-03
 [80,] 1.783821e-03
 [81,] 3.180427e-03
 [82,] 1.924911e-03
 [83,] 2.423611e-03
 [84,] 1.486153e-02
 [85,] 2.068766e-03
 [86,] 1.616160e-02
 [87,] 9.339511e-03
 [88,] 1.390024e-02
 [89,] 3.789563e-02
 [90,] 3.750888e-03
 [91,] 8.335454e-03
 [92,] 6.823073e-03
 [93,] 1.152500e-01
 [94,] 2.425237e-02
 [95,] 1.070093e-03
 [96,] 1.434706e-02
 [97,] 1.300086e-03
 [98,] 8.053401e-04
 [99,] 4.119387e-04
[100,] 6.823073e-03
[101,] 1.042223e-02
[102,] 1.264383e-01
[103,] 1.819900e-02
[104,] 9.426792e-03
[105,] 1.858209e-02
[106,] 4.960533e-04
[107,] 1.154605e-02
[108,] 1.101470e-02
[109,] 1.885227e-03
[110,] 2.869300e-02
[111,] 3.789563e-02
[112,] 2.193280e-03
[113,] 1.525157e-02
[114,] 2.316091e-02
[115,] 2.383616e-03
[116,] 5.495746e-03
[117,] 3.177860e-02
[118,] 8.654954e-03
[119,] 3.361226e-03
[120,] 8.483369e-04
[121,] 3.291931e-03
[122,] 1.284933e-02
[123,] 1.147444e-02
[124,] 5.748279e-03
[125,] 5.149310e-02
[126,] 9.505245e-04
[127,] 5.988205e-03
[128,] 7.755833e-03
[129,] 3.095398e-02
[130,] 1.821370e-03
[131,] 3.791371e-03
[132,] 5.666101e-03
[133,] 1.064161e-02
[134,] 2.155038e-02
[135,] 4.773557e-03
[136,] 3.964116e-03
[137,] 1.957488e-03
[138,] 5.968612e-03
[139,] 3.242623e-02
[140,] 2.586680e-03
[141,] 2.041436e-02
[142,] 3.418111e-03
[143,] 9.587239e-04
[144,] 2.357191e-03
[145,] 8.965628e-04
[146,] 8.661945e-04
[147,] 4.678921e-04
[148,] 1.101470e-02
[149,] 7.251235e-02
[150,] 3.726896e-02
[151,] 7.831306e-02
[152,] 1.021560e-03
[153,] 1.143690e-02
[154,] 2.641130e-03
[155,] 7.445348e-04
[156,] 3.514603e-02
[157,] 2.618734e-03
[158,] 3.726896e-02
[159,] 7.730730e-04
[160,] 8.740575e-03
[161,] 4.034461e-04
[162,] 1.114791e-02
[163,] 1.511304e-02
[164,] 1.426658e-03
[165,] 3.829844e-03
[166,] 1.230155e-03
[167,] 7.830219e-03
[168,] 5.060864e-03
[169,] 2.095445e-03
[170,] 3.396506e-02
[171,] 5.869281e-03
[172,] 2.733726e-03
[173,] 1.234149e-02
[174,] 2.537447e-05
[175,] 2.425237e-02
[176,] 1.223256e-02
[177,] 3.226668e-04
[178,] 7.595938e-03
[179,] 5.850284e-04
[180,] 2.135234e-02
[181,] 1.042223e-02
[182,] 8.053401e-04
[183,] 8.661945e-04
[184,] 1.184743e-03
[185,] 9.146967e-03
[186,] 7.972720e-05
[187,] 1.231149e-04
[188,] 6.616609e-03
[189,] 3.750888e-03
[190,] 2.898364e-04
[191,] 2.013372e-03
[192,] 3.964116e-03
[193,] 1.354302e-02
[194,] 1.789676e-03
[195,] 1.472864e-02
[196,] 6.419849e-04
[197,] 9.083777e-04
[198,] 8.591512e-03
[199,] 4.427243e-04
[200,] 2.310460e-04
[201,] 4.927806e-04
[202,] 5.869489e-04
[203,] 2.491192e-03
[204,] 4.116062e-03
[205,] 7.893463e-04
> predict(fit5.2,cause=2,newdata=Melanoma,times=100)
     observation invasion      epicel age times     strata  absRisk
  1:           1  level.1     present  76   100   sex=Male 0.060242
  2:           2  level.0 not present  56   100   sex=Male 0.016734
  3:           3  level.1 not present  41   100   sex=Male 0.001835
  4:           4  level.0 not present  71   100 sex=Female 0.028959
  5:           5  level.2     present  52   100   sex=Male 0.004164
 ---                                                               
201:         201  level.2     present  29   100   sex=Male 0.000493
202:         202  level.2     present  40   100 sex=Female 0.000587
203:         203  level.0     present  42   100 sex=Female 0.002491
204:         204  level.0 not present  50   100 sex=Female 0.004116
205:         205  level.1 not present  41   100 sex=Female 0.000789
> predict(fit5.2,cause=2,newdata=Melanoma[4,],times=100)
   observation invasion      epicel age times     strata absRisk
1:           1  level.0 not present  71   100 sex=Female   0.029
> 
> 
> 
> 
> cleanEx()

detaching ‘package:survival’, ‘package:prodlim’

> nameEx("Ctree")
> ### * Ctree
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Ctree
> ### Title: S3-Wrapper for ctree.
> ### Aliases: Ctree
> 
> ### ** Examples
> 
> library(prodlim)
> library(party)
Loading required package: grid
Loading required package: mvtnorm
Loading required package: modeltools
Loading required package: stats4
Loading required package: strucchange
Loading required package: zoo

Attaching package: ‘zoo’

The following objects are masked from ‘package:base’:

    as.Date, as.Date.numeric

Loading required package: sandwich
> library(survival)
> set.seed(50)
> d <- SimSurv(50)
> nd <- data.frame(X1=c(0,1,0),X2=c(-1,0,1))
> f <- Ctree(Surv(time,status)~X1+X2,data=d)
> predictRisk(f,newdata=nd,times=c(3,8))
           [,1]      [,2]
[1,] 0.09090909 0.2975207
[2,] 0.00000000 0.7460317
[3,] 0.33333333 0.7777778
> 
> 
> 
> 
> cleanEx()

detaching ‘package:survival’, ‘package:party’, ‘package:strucchange’,
  ‘package:sandwich’, ‘package:zoo’, ‘package:modeltools’,
  ‘package:stats4’, ‘package:mvtnorm’, ‘package:grid’,
  ‘package:prodlim’

> nameEx("FGR")
> ### * FGR
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: FGR
> ### Title: Formula wrapper for crr from cmprsk
> ### Aliases: FGR
> ### Keywords: survival
> 
> ### ** Examples
> 
> 
> library(prodlim)
> library(survival)
> library(cmprsk)
> library(lava)
> d <- prodlim::SimCompRisk(100)
> f1 <- FGR(Hist(time,cause)~X1+X2,data=d)
Argument cause missing. Analyse cause: 1
> print(f1)

Right-censored response of a competing.risks model

No.Observations: 100 

Pattern:
         
Cause     event right.censored
  1          47              0
  2          26              0
  unknown     0             27


Fine-Gray model: analysis of cause 1 

Competing Risks Regression

Call:
FGR(formula = Hist(time, cause) ~ X1 + X2, data = d, cause = "1")

    coef exp(coef) se(coef)    z p-value
X1 1.200      3.32    0.343 3.50 0.00046
X2 0.869      2.39    0.244 3.56 0.00036

   exp(coef) exp(-coef) 2.5% 97.5%
X1      3.32      0.301 1.70  6.50
X2      2.39      0.419 1.48  3.85

Num. cases = 100
Pseudo Log-likelihood = -172 
Pseudo likelihood ratio test = 36.9  on 2 df,

Convergence: TRUE 

> 
> ## crr allows that some covariates are multiplied by
> ## a function of time (see argument tf of crr)
> ## by FGR uses the identity matrix
> f2 <- FGR(Hist(time,cause)~cov2(X1)+X2,data=d)
Argument cause missing. Analyse cause: 1
> print(f2)

Right-censored response of a competing.risks model

No.Observations: 100 

Pattern:
         
Cause     event right.censored
  1          47              0
  2          26              0
  unknown     0             27


Fine-Gray model: analysis of cause 1 

Competing Risks Regression

Call:
FGR(formula = Hist(time, cause) ~ cov2(X1) + X2, data = d, cause = "1")

        coef exp(coef) se(coef)    z p-value
X2     0.854      2.35   0.2254 3.79 0.00015
X1*tf1 0.176      1.19   0.0865 2.04 0.04200

       exp(coef) exp(-coef) 2.5% 97.5%
X2          2.35      0.426 1.51  3.66
X1*tf1      1.19      0.839 1.01  1.41

Num. cases = 100
Pseudo Log-likelihood = -177 
Pseudo likelihood ratio test = 27.5  on 2 df,

Convergence: TRUE 

> 
> ## same thing, but more explicit:
> f3 <- FGR(Hist(time,cause)~cov2(X1)+cov1(X2),data=d)
Argument cause missing. Analyse cause: 1
> print(f3)

Right-censored response of a competing.risks model

No.Observations: 100 

Pattern:
         
Cause     event right.censored
  1          47              0
  2          26              0
  unknown     0             27


Fine-Gray model: analysis of cause 1 

Competing Risks Regression

Call:
FGR(formula = Hist(time, cause) ~ cov2(X1) + cov1(X2), data = d, 
    cause = "1")

        coef exp(coef) se(coef)    z p-value
X2     0.854      2.35   0.2254 3.79 0.00015
X1*tf1 0.176      1.19   0.0865 2.04 0.04200

       exp(coef) exp(-coef) 2.5% 97.5%
X2          2.35      0.426 1.51  3.66
X1*tf1      1.19      0.839 1.01  1.41

Num. cases = 100
Pseudo Log-likelihood = -177 
Pseudo likelihood ratio test = 27.5  on 2 df,

Convergence: TRUE 

> 
> ## both variables can enter cov2:
> f4 <- FGR(Hist(time,cause)~cov2(X1)+cov2(X2),data=d)
Argument cause missing. Analyse cause: 1
> print(f4)

Right-censored response of a competing.risks model

No.Observations: 100 

Pattern:
         
Cause     event right.censored
  1          47              0
  2          26              0
  unknown     0             27


Fine-Gray model: analysis of cause 1 

Competing Risks Regression

Call:
FGR(formula = Hist(time, cause) ~ cov2(X1) + cov2(X2), data = d, 
    cause = "1")

        coef exp(coef) se(coef)    z p-value
X1*tf1 0.168      1.18   0.0800 2.10   0.036
X2*tf2 0.115      1.12   0.0509 2.25   0.024

       exp(coef) exp(-coef) 2.5% 97.5%
X1*tf1      1.18      0.845 1.01  1.38
X2*tf2      1.12      0.892 1.02  1.24

Num. cases = 100
Pseudo Log-likelihood = -183 
Pseudo likelihood ratio test = 14.4  on 2 df,

Convergence: TRUE 

> 
> ## change the function of time
> qFun <- function(x){x^2}
> noFun <- function(x){x}
> sqFun <- function(x){x^0.5}
> 
> ## multiply X1 by time^2 and X2 by time:
> f5 <- FGR(Hist(time,cause)~cov2(X1,tf=qFun)+cov2(X2),data=d)
Argument cause missing. Analyse cause: 1
> print(f5)

Right-censored response of a competing.risks model

No.Observations: 100 

Pattern:
         
Cause     event right.censored
  1          47              0
  2          26              0
  unknown     0             27


Fine-Gray model: analysis of cause 1 

Competing Risks Regression

Call:
FGR(formula = Hist(time, cause) ~ cov2(X1, tf = qFun) + cov2(X2), 
    data = d, cause = "1")

         coef exp(coef) se(coef)     z p-value
X1*tf1 0.0112      1.01   0.0121 0.926   0.350
X2*tf2 0.1183      1.13   0.0476 2.486   0.013

       exp(coef) exp(-coef)  2.5% 97.5%
X1*tf1      1.01      0.989 0.988  1.04
X2*tf2      1.13      0.888 1.025  1.24

Num. cases = 100
Pseudo Log-likelihood = -186 
Pseudo likelihood ratio test = 9.7  on 2 df,

Convergence: TRUE 

> print(f5$crrFit)
convergence:  TRUE 
coefficients:
X1*tf1 X2*tf2 
0.0112 0.1183 
standard errors:
[1] 0.01209 0.04760
two-sided p-values:
X1*tf1 X2*tf2 
 0.350  0.013 
> ## same results as crr
> with(d,crr(ftime=time,
+            fstatus=cause,
+            cov2=d[,c("X1","X2")],
+            tf=function(time){cbind(qFun(time),time)}))
convergence:  TRUE 
coefficients:
 X1*tf1 X2*time 
 0.0112  0.1183 
standard errors:
[1] 0.01209 0.04760
two-sided p-values:
 X1*tf1 X2*time 
  0.350   0.013 
> 
> ## still same result, but more explicit
> f5a <- FGR(Hist(time,cause)~cov2(X1,tf=qFun)+cov2(X2,tf=noFun),data=d)
Argument cause missing. Analyse cause: 1
> f5a$crrFit
convergence:  TRUE 
coefficients:
X1*tf1 X2*tf2 
0.0112 0.1183 
standard errors:
[1] 0.01209 0.04760
two-sided p-values:
X1*tf1 X2*tf2 
 0.350  0.013 
> 
> ## multiply X1 by time^2 and X2 by sqrt(time)
> f5b <- FGR(Hist(time,cause)~cov2(X1,tf=qFun)+cov2(X2,tf=sqFun),data=d,cause=1)
> 
> ## additional arguments for crr
> f6<- FGR(Hist(time,cause)~X1+X2,data=d, cause=1,gtol=1e-5)
> f6

Right-censored response of a competing.risks model

No.Observations: 100 

Pattern:
         
Cause     event right.censored
  1          47              0
  2          26              0
  unknown     0             27


Fine-Gray model: analysis of cause 1 

Competing Risks Regression

Call:
FGR(formula = Hist(time, cause) ~ X1 + X2, data = d, cause = 1, 
    gtol = 1e-05)

    coef exp(coef) se(coef)    z p-value
X1 1.200      3.32    0.343 3.50 0.00046
X2 0.869      2.39    0.244 3.56 0.00036

   exp(coef) exp(-coef) 2.5% 97.5%
X1      3.32      0.301 1.70  6.50
X2      2.39      0.419 1.48  3.85

Num. cases = 100
Pseudo Log-likelihood = -172 
Pseudo likelihood ratio test = 36.9  on 2 df,

Convergence: TRUE 

> f6a<- FGR(Hist(time,cause)~X1+X2,data=d, cause=1,gtol=0.1)
> f6a

Right-censored response of a competing.risks model

No.Observations: 100 

Pattern:
         
Cause     event right.censored
  1          47              0
  2          26              0
  unknown     0             27


Fine-Gray model: analysis of cause 1 

Competing Risks Regression

Call:
FGR(formula = Hist(time, cause) ~ X1 + X2, data = d, cause = 1, 
    gtol = 0.1)

    coef exp(coef) se(coef)    z p-value
X1 1.425      4.16    0.355 4.01 0.00006
X2 0.869      2.39    0.258 3.37 0.00076

   exp(coef) exp(-coef) 2.5% 97.5%
X1      4.16      0.240 2.07  8.34
X2      2.39      0.419 1.44  3.96

Num. cases = 100
Pseudo Log-likelihood = -172 
Pseudo likelihood ratio test = 36.3  on 2 df,

Convergence: TRUE 

> 
> 
> 
> cleanEx()

detaching ‘package:lava’, ‘package:cmprsk’, ‘package:survival’,
  ‘package:prodlim’

> nameEx("IPA")
> ### * IPA
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: IPA
> ### Title: Explained variation for settings with binary, survival and
> ###   competing risk outcome
> ### Aliases: IPA rsquared rsquared.default rsquared.glm rsquared.coxph
> ###   rsquared.CauseSpecificCox IPA.default IPA.glm IPA.coxph
> ###   IPA.CauseSpecificCox
> 
> ### ** Examples
> 
> library(prodlim)
> library(data.table)
> # binary outcome
> library(lava)
> set.seed(18)
> learndat <- sampleData(48,outcome="binary")
> lr1 = glm(Y~X1+X2+X7+X9,data=learndat,family=binomial)
> IPA(lr1)
     Variable Brier  IPA IPA.drop
1: Null model  24.8  0.0     37.1
2: Full model  15.6 37.1      0.0
3:         X1  19.5 21.6     15.5
4:         X2  15.8 36.3      0.8
5:         X7  16.0 35.4      1.7
6:         X9  21.2 14.6     22.5

NOTE: Values are multiplied by 100 and given in % (use print(...,percent=FALSE) to avoid this.
NOTE: IPA.drop = IPA(Full model) - IPA.
> 
> ## validation data
> valdat=sampleData(94,outcome="binary")
> IPA(lr1,newdata=valdat)
     Variable Brier  IPA IPA.drop
1: Null model  23.6  0.0     -1.3
2: Full model  23.9 -1.3      0.0
3:         X1  23.9 -0.9     -0.3
4:         X2  23.2  1.9     -3.1
5:         X7  24.0 -1.7      0.4
6:         X9  23.5  0.5     -1.8

NOTE: Values are multiplied by 100 and given in % (use print(...,percent=FALSE) to avoid this.
NOTE: IPA.drop = IPA(Full model) - IPA.
> 
> ## predicted risks externally given
> p1=predictRisk(lr1,newdata=valdat)
> IPA(p1,formula=Y~1,valdat)
        model Brier  IPA
1: Null model  23.6  0.0
2:    numeric  23.9 -1.3

NOTE: Values are multiplied by 100 and given in % (use print(...,percent=FALSE) to avoid this.
NOTE: IPA.drop = IPA(Full model) - IPA.
> 
> # survival
> library(survival)
> data(pbc)
> pbc=na.omit(pbc)
> pbctest=(1:NROW(pbc)) %in% sample(1:NROW(pbc),size=.632*NROW(pbc))
> pbclearn=pbc[pbctest,]
> cox1= coxph(Surv(time,status!=0)~age+sex+log(bili)+log(albumin)+log(protime),
+       data=pbclearn,x=TRUE)
> 
> ## same data
> IPA(cox1,formula=Surv(time,status!=0)~1,times=1000)
       Variable times Brier  IPA IPA.drop
1:   Null model  1000  13.5  0.0     31.8
2:   Full model  1000   9.2 31.8      0.0
3:          age  1000   9.2 31.9     -0.2
4:          sex  1000   9.2 31.9     -0.2
5:    log(bili)  1000  11.7 13.6     18.2
6: log(albumin)  1000   9.8 27.5      4.2
7: log(protime)  1000   9.4 30.9      0.9

NOTE: Values are multiplied by 100 and given in % (use print(...,percent=FALSE) to avoid this.
NOTE: IPA.drop = IPA(Full model) - IPA.
> 
> ## validation data
> pbcval=pbc[!pbctest,]
> IPA(cox1,formula=Surv(time,status!=0)~1,newdata=pbcval,times=1000)
       Variable times Brier  IPA IPA.drop
1:   Null model  1000  18.5  0.0     25.1
2:   Full model  1000  13.9 25.1      0.0
3:          age  1000  14.0 24.4      0.6
4:          sex  1000  13.9 24.8      0.3
5:    log(bili)  1000  15.2 18.0      7.1
6: log(albumin)  1000  13.7 25.9     -0.8
7: log(protime)  1000  14.2 23.4      1.7

NOTE: Values are multiplied by 100 and given in % (use print(...,percent=FALSE) to avoid this.
NOTE: IPA.drop = IPA(Full model) - IPA.
> 
> ## predicted risks externally given
> p2=predictRisk(cox1,newdata=pbcval,times=1000)
> IPA(cox1,formula=Surv(time,status!=0)~1,newdata=pbcval,times=1000)
       Variable times Brier  IPA IPA.drop
1:   Null model  1000  18.5  0.0     25.1
2:   Full model  1000  13.9 25.1      0.0
3:          age  1000  14.0 24.4      0.6
4:          sex  1000  13.9 24.8      0.3
5:    log(bili)  1000  15.2 18.0      7.1
6: log(albumin)  1000  13.7 25.9     -0.8
7: log(protime)  1000  14.2 23.4      1.7

NOTE: Values are multiplied by 100 and given in % (use print(...,percent=FALSE) to avoid this.
NOTE: IPA.drop = IPA(Full model) - IPA.
>  
> # competing risks
> data(Melanoma)
> Melanomatest=(1:NROW(Melanoma)) %in% sample(1:NROW(Melanoma),size=.632*NROW(Melanoma))
> Melanomalearn=Melanoma[Melanomatest,]
> fit1 <- CSC(list(Hist(time,status)~sex,
+                  Hist(time,status)~invasion+epicel+age),
+                  data=Melanoma)
> IPA(fit1,times=1000,cause=2)
     Variable times Brier  IPA IPA.drop
1: Null model  1000   3.3  0.0      2.9
2: Full model  1000   3.2  2.9      0.0
3:        sex  1000   3.2  2.8      0.1
4:   invasion  1000   3.2  4.0     -1.2
5:     epicel  1000   3.2  3.1     -0.2
6:        age  1000   3.3 -0.8      3.6

NOTE: Values are multiplied by 100 and given in % (use print(...,percent=FALSE) to avoid this.
NOTE: IPA.drop = IPA(Full model) - IPA.
> 
> ## validation data
> Melanomaval=Melanoma[!Melanomatest,]
> IPA(fit1,formula=Hist(time,status)~1,newdata=Melanomaval,times=1000)
     Variable times Brier  IPA IPA.drop
1: Null model  1000  11.6  0.0      4.6
2: Full model  1000  11.0  4.6      0.0
3:        sex  1000  11.6 -0.0      4.6
4:   invasion  1000  11.0  4.4      0.2
5:     epicel  1000  11.0  4.5      0.1
6:        age  1000  11.0  4.6     -0.0

NOTE: Values are multiplied by 100 and given in % (use print(...,percent=FALSE) to avoid this.
NOTE: IPA.drop = IPA(Full model) - IPA.
> 
> ## predicted risks externally given
> p3= predictRisk(fit1,cause=1,newdata=Melanomaval,times=1000)
> IPA(p3,formula=Hist(time,status)~1,cause=1,newdata=Melanomaval,times=1000)
        model times Brier IPA
1: Null model  1000  11.6 0.0
2:     matrix  1000  11.0 4.6

NOTE: Values are multiplied by 100 and given in % (use print(...,percent=FALSE) to avoid this.
NOTE: IPA.drop = IPA(Full model) - IPA.
>  
> 
> 
> 
> cleanEx()

detaching ‘package:survival’, ‘package:lava’, ‘package:data.table’,
  ‘package:prodlim’

> nameEx("Melanoma")
> ### * Melanoma
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Melanoma
> ### Title: Malignant melanoma data
> ### Aliases: Melanoma
> ### Keywords: datasets
> 
> ### ** Examples
> 
> 
> data(Melanoma)
> 
> 
> 
> cleanEx()
> nameEx("Paquid")
> ### * Paquid
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Paquid
> ### Title: Paquid sample
> ### Aliases: Paquid
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(Paquid)
> 
> 
> 
> cleanEx()
> nameEx("Score.list")
> ### * Score.list
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Score.list
> ### Title: Score risk predictions
> ### Aliases: Score.list Score
> 
> ### ** Examples
> 
> # binary outcome
> library(lava)
> set.seed(18)
> learndat <- sampleData(48,outcome="binary")
> testdat <- sampleData(40,outcome="binary")
> 
> ## score logistic regression models
> lr1 = glm(Y~X1+X2+X7+X9,data=learndat,family=binomial)
> lr2 = glm(Y~X3+X5,data=learndat,family=binomial)
> Score(list("LR(X1+X2+X7+X9)"=lr1,"LR(X3+X5)"=lr2),formula=Y~1,data=testdat)

Metric AUC:

Results by model:

             model  AUC lower upper
1: LR(X1+X2+X7+X9) 60.7  42.3  79.1
2:       LR(X3+X5) 44.2  26.9  61.6

Results of model comparisons:

       model       reference delta.AUC lower upper   p
1: LR(X3+X5) LR(X1+X2+X7+X9)     -16.4 -38.2   5.3 0.1

NOTE: Values are multiplied by 100 and given in % (use print(...,percent=FALSE) to avoid this.

NOTE: The higher AUC the better.

Metric Brier:

Results by model:

             model Brier lower upper
1:      Null model  24.9  24.2  25.7
2: LR(X1+X2+X7+X9)  27.9  19.0  36.8
3:       LR(X3+X5)  25.4  24.0  26.9

Results of model comparisons:

             model       reference delta.Brier lower upper         p
1: LR(X1+X2+X7+X9)      Null model         3.0  -5.9  11.8 0.5124805
2:       LR(X3+X5)      Null model         0.5  -0.4   1.4 0.2747143
3:       LR(X3+X5) LR(X1+X2+X7+X9)        -2.5 -11.1   6.2 0.5778617

NOTE: Values are multiplied by 100 and given in % (use print(...,percent=FALSE) to avoid this.

NOTE: The lower Brier the better.
> 
> ## ROC curve and calibration plot
> xb=Score(list("LR(X1+X2+X7+X9)"=lr1,"LR(X3+X5+X6)"=lr2),formula=Y~1,
+          data=testdat,plots=c("calibration","ROC"))
> ## Not run: 
> ##D plotROC(xb)
> ##D plotCalibration(xb)
> ## End(Not run)
> 
> ## compute AUC for a list of continuous markers
> markers = as.list(testdat[,.(X6,X7,X8,X9,X10)])
> Score(markers,formula=Y~1,data=testdat,metrics=c("auc"))

Metric AUC:

Results by model:

   model  AUC lower upper
1:    X6 86.7  75.3  98.2
2:    X7 38.6  20.7  56.5
3:    X8 46.4  27.7  65.0
4:    X9 35.3  17.9  52.8
5:   X10 46.4  27.8  65.0

Results of model comparisons:

    model reference delta.AUC lower upper     p
 1:    X7        X6     -48.1 -69.7 -26.6 1e-05
 2:    X8        X6     -40.4 -63.6 -17.1 7e-04
 3:    X9        X6     -51.4 -73.3 -29.4 4e-06
 4:   X10        X6     -40.4 -61.8 -18.9 2e-04
 5:    X8        X7       7.8 -17.0  32.6 5e-01
 6:    X9        X7      -3.3 -26.6  20.1 8e-01
 7:   X10        X7       7.8 -17.4  32.9 5e-01
 8:    X9        X8     -11.0 -34.8  12.7 4e-01
 9:   X10        X8       0.0 -27.4  27.4 1e+00
10:   X10        X9      11.0 -12.1  34.2 4e-01

NOTE: Values are multiplied by 100 and given in % (use print(...,percent=FALSE) to avoid this.

NOTE: The higher AUC the better.
> 
> # cross-validation
> ## Not run: 
> ##D     learndat=sampleData(400,outcome="binary")
> ##D     lr1a = glm(Y~X6,data=learndat,family=binomial)
> ##D     lr2a = glm(Y~X7+X8+X9,data=learndat,family=binomial)
> ##D     ## bootstrap cross-validation
> ##D     x1=Score(list("LR1"=lr1a,"LR2"=lr2a),formula=Y~1,data=learndat,split.method="bootcv",B=100)
> ##D     x1
> ##D     ## leave-one-out and leave-pair-out bootstrap
> ##D     x2=Score(list("LR1"=lr1a,"LR2"=lr2a),formula=Y~1,data=learndat,
> ##D              split.method="loob",
> ##D              B=100,plots="calibration")
> ##D     x2
> ## End(Not run)
> # survival outcome
> 
> # Score Cox regression models
> ## Not run: 
> ##D library(survival)
> ##D library(rms)
> ##D library(prodlim)
> ##D set.seed(18)
> ##D trainSurv <- sampleData(100,outcome="survival")
> ##D testSurv <- sampleData(40,outcome="survival")
> ##D cox1 = coxph(Surv(time,event)~X1+X2+X7+X9,data=trainSurv, y=TRUE, x = TRUE)
> ##D cox2 = coxph(Surv(time,event)~X3+X5+X6,data=trainSurv, y=TRUE, x = TRUE)
> ##D xs=Score(list("Cox(X1+X2+X7+X9)"=cox1,"Cox(X3+X5+X6)"=cox2),
> ##D          formula=Surv(time,event)~1,data=testSurv,conf.int=FALSE,times=c(5,8))
> ##D xs
> ## End(Not run)
> 
> # Integrated Brier score
> ## Not run: 
> ##D xs=Score(list("Cox(X1+X2+X7+X9)"=cox1,"Cox(X3+X5+X6)"=cox2),
> ##D          formula=Surv(time,event)~1,data=testSurv,conf.int=FALSE,
> ##D          summary="ibs",
> ##D          times=sort(unique(testSurv$time)))
> ## End(Not run)
> 
> # time-dependent AUC for list of markers
> ## Not run: 
> ##D survmarkers = as.list(testSurv[,.(X6,X7,X8,X9,X10)])
> ##D Score(survmarkers,
> ##D       formula=Surv(time,event)~1,metrics="auc",data=testSurv,
> ##D       conf.int=TRUE,times=c(5,8))
> ##D 
> ##D # compare models on test data
> ##D Score(list("Cox(X1+X2+X7+X9)"=cox1,"Cox(X3+X5+X6)"=cox2),
> ##D       formula=Surv(time,event)~1,data=testSurv,conf.int=TRUE,times=c(5,8))
> ## End(Not run)
> # crossvalidation models in traindata
> ## Not run: 
> ##D     library(survival)
> ##D     set.seed(18)
> ##D     trainSurv <- sampleData(400,outcome="survival")
> ##D     cox1 = coxph(Surv(time,event)~X1+X2+X7+X9,data=trainSurv, y=TRUE, x = TRUE)
> ##D     cox2 = coxph(Surv(time,event)~X3+X5+X6,data=trainSurv, y=TRUE, x = TRUE)
> ##D     x1 = Score(list("Cox(X1+X2+X7+X9)"=cox1,"Cox(X3+X5+X6)"=cox2),
> ##D                formula=Surv(time,event)~1,data=trainSurv,conf.int=TRUE,times=c(5,8),
> ##D                split.method="loob",B=100,plots="calibration")
> ##D 
> ##D     x2= Score(list("Cox(X1+X2+X7+X9)"=cox1,"Cox(X3+X5+X6)"=cox2),
> ##D               formula=Surv(time,event)~1,data=trainSurv,conf.int=TRUE,times=c(5,8),
> ##D               split.method="bootcv",B=100)
> ## End(Not run)
> 
> # restrict number of comparisons
> ## Not run: 
> ##D     Score(list("Cox(X1+X2+X7+X9)"=cox1,"Cox(X3+X5+X6)"=cox2),
> ##D           formula=Surv(time,event)~1,data=trainSurv,contrasts=TRUE,
> ##D           null.model=FALSE,conf.int=TRUE,times=c(5,8),split.method="bootcv",B=3)
> ##D 
> ##D     # competing risks outcome
> ##D     set.seed(18)
> ##D     trainCR <- sampleData(40,outcome="competing.risks")
> ##D     testCR <- sampleData(40,outcome="competing.risks")
> ##D     library(riskRegression)
> ##D     library(cmprsk)
> ##D     # Cause-specific Cox regression
> ##D     csc1 = CSC(Hist(time,event)~X1+X2+X7+X9,data=trainCR)
> ##D     csc2 = CSC(Hist(time,event)~X3+X5+X6,data=trainCR)
> ##D     # Fine-Gray regression
> ##D     fgr1 = FGR(Hist(time,event)~X1+X2+X7+X9,data=trainCR,cause=1)
> ##D     fgr2 = FGR(Hist(time,event)~X3+X5+X6,data=trainCR,cause=1)
> ##D     Score(list("CSC(X1+X2+X7+X9)"=csc1,"CSC(X3+X5+X6)"=csc2,
> ##D                "FGR(X1+X2+X7+X9)"=fgr1,"FGR(X3+X5+X6)"=fgr2),
> ##D           formula=Hist(time,event)~1,data=testCR,se.fit=1L,times=c(5,8))
> ## End(Not run)
> 
> 
> 
> ## Not run: 
> ##D     # reproduce some results of Table IV of Blanche et al. Stat Med 2013
> ##D     data(Paquid)
> ##D     ResPaquid <- Score(list("DSST"=-Paquid$DSST,"MMSE"=-Paquid$MMSE),
> ##D                        formula=Hist(time,status)~1,
> ##D                        data=Paquid,
> ##D                        null.model = FALSE,
> ##D                        conf.int=TRUE,
> ##D                        metrics=c("auc"),
> ##D                        times=c(3,5,10),
> ##D                        plots="ROC")
> ##D     ResPaquid
> ##D     plotROC(ResPaquid,time=5)
> ## End(Not run)
> 
> 
> 
> cleanEx()

detaching ‘package:lava’

> nameEx("SuperPredictor")
> ### * SuperPredictor
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: SuperPredictor
> ### Title: Formula interface for SuperLearner::SuperLearner
> ### Aliases: SuperPredictor
> 
> ### ** Examples
> 
> ## Not run: 
> ##D library(SuperLearner)
> ##D library(data.table)
> ##D d = sampleData(338, outcome="binary")
> ##D spfit = SuperPredictor(Y~X1+X2+X3+X4+X5+X6+X7+X8+X9+X10,data=d)
> ##D predictRisk(spfit)
> ##D x <- Score(list(spfit),data=d,formula=Y~1)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("SurvResponseVar")
> ### * SurvResponseVar
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: SurvResponseVar
> ### Title: Extract the time and event variable from a Cox model
> ### Aliases: SurvResponseVar
> 
> ### ** Examples
> 
> ## Not run: 
> ##D SurvResponseVar(Surv(time,event)~X1+X2)
> ##D SurvResponseVar(Hist(time,event==0)~X1+X2)
> ##D SurvResponseVar(Surv(start,time, status,type="counting") ~ X3+X5)
> ##D SurvResponseVar(Surv(start,event=status, time2=time,type="counting") ~ X3+X5)
> ##D 
> ##D SurvResponseVar(survival::Surv(start,event=status, time2=time,type="counting") ~ X3+X5)
> ##D SurvResponseVar(status ~ X3+X5)
> ##D SurvResponseVar(I(status == 1) ~ X3+X5)
> ##D SurvResponseVar(list(Hist(time, event) ~ X1+X6,Hist(time, event) ~ X6))
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("ate")
> ### * ate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ate
> ### Title: Compute the Average Treatment Effects Via
> ### Aliases: ate
> 
> ### ** Examples
> 
> library(survival)
> library(rms)
Loading required package: Hmisc
Loading required package: lattice
Loading required package: Formula
Loading required package: ggplot2

Attaching package: ‘Hmisc’

The following objects are masked from ‘package:base’:

    format.pval, units

Loading required package: SparseM

Attaching package: ‘SparseM’

The following object is masked from ‘package:base’:

    backsolve

> library(prodlim)
> set.seed(10)
> 
> #### Survival settings  ####
> #### ATE with Cox model ####
> 
> ## generate data
> n <- 100
> dtS <- sampleData(n, outcome="survival")
> dtS$time <- round(dtS$time,1)
> dtS$X1 <- factor(rbinom(n, prob = c(0.3,0.4) , size = 2), labels = paste0("T",0:2))
> 
> ## estimate the Cox model
> fit <- cph(formula = Surv(time,event)~ X1+X2,data=dtS,y=TRUE,x=TRUE)
> 
> ## compute the ATE at times 5, 6, 7, and 8 using X1 as the treatment variable
> ## Not run: 
> ##D ## only point estimate (argument se = FALSE)
> ##D ateFit1a <- ate(fit, data = dtS, treatment = "X1", times = 5:8,
> ##D                se = FALSE)
> ##D 
> ##D ## standard error / confidence intervals computed using the influence function
> ##D ## (argument se = TRUE and B = 0)
> ##D ateFit1b <- ate(fit, data = dtS, treatment = "X1", times = 5:8,
> ##D                se = TRUE, B = 0)
> ##D 
> ##D ## same as before with in addition the confidence bands for the ATE
> ##D ## (argument band = TRUE)
> ##D ateFit1c <- ate(fit, data = dtS, treatment = "X1", times = 5:8,
> ##D                se = TRUE, band = TRUE, B = 0)
> ##D 
> ##D ## standard error / confidence intervals computed using 100 boostrap samples
> ##D ## (argument se = TRUE and B = 100) 
> ##D ateFit1d <- ate(fit, data = dtS, treatment = "X1",
> ##D                 times = 5:8, se = TRUE, B = 100)
> ##D ## NOTE: for real applications 100 bootstrap samples is not enougth 
> ##D 
> ##D ## same but using 2 cpus for generating and analyzing the boostrap samples
> ##D ## (parallel computation, argument mc.cores = 2) 
> ##D ateFit1e <- ate(fit, data = dtS, treatment = "X1",
> ##D                 times = 5:8, se = TRUE, B = 100, mc.cores = 2)
> ## End(Not run)
> 
> #### Survival settings without censoring ####
> #### ATE with glm                        ####
> 
> ## generate data
> n <- 100
> dtB <- sampleData(n, outcome="binary")
> dtB[, X2 := as.numeric(X2)]
> 
> ## estimate a logistic regression model
> fit <- glm(formula = Y ~ X1+X2, data=dtB, family = "binomial")
> 
> ## compute the ATE using X1 as the treatment variable
> ## only point estimate (argument se = FALSE)
> ateFit1a <- ate(fit, data = dtB, treatment = "X1", se = FALSE)
     Calculation of the average treatment effect 

 - Estimator         : Gformula
 - Treatment variable: X1 (2 levels)
 - Event variable    : Y (cause: 1)
 - Time variable     : NA

 - Point estimation: done 
> 
> ## Not run: 
> ##D ## standard error / confidence intervals computed using the influence function
> ##D ateFit1b <- ate(fit, data = dtB, treatment = "X1",
> ##D                times = 5, ## just for having a nice output not used in computations
> ##D                se = TRUE, B = 0)
> ##D 
> ##D ## standard error / confidence intervals computed using 100 boostrap samples
> ##D ateFit1d <- ate(fit, data = dtB, treatment = "X1",
> ##D                 times = 5, se = TRUE, B = 100)
> ##D 
> ##D ## using the lava package
> ##D ateLava <- estimate(fit, function(p, data){
> ##D a <- p["(Intercept)"] ; b <- p["X11"] ; c <- p["X2"] ;
> ##D R.X11 <- expit(a + b + c * data[["X2"]])
> ##D R.X10 <- expit(a + c * data[["X2"]])
> ##D list(risk0=R.X10,risk1=R.X11,riskdiff=R.X11-R.X10)},
> ##D average=TRUE)
> ##D ateLava
> ##D 
> ##D ateFit1b$meanRisk
> ## End(Not run)
> 
> #### Competing risks settings               ####
> #### ATE with cause specific Cox regression ####
> 
> ## Not run: 
> ##D ## generate data
> ##D n <- 500
> ##D set.seed(10)
> ##D dt <- sampleData(n, outcome="competing.risks")
> ##D dt$time <- round(dt$time,1)
> ##D dt$X1 <- factor(rbinom(n, prob = c(0.2,0.3) , size = 2), labels = paste0("T",0:2))
> ##D 
> ##D ## estimate cause specific Cox model
> ##D fitCR <-  CSC(Hist(time,event)~ X1+X8,data=dt,cause=1)
> ##D 
> ##D ## compute the ATE at times 10, 15, 20 using X1 as the treatment variable
> ##D ateFit2a <- ate(fitCR, data = dt, treatment = "X1", times = c(10,15,20),
> ##D                 cause = 1, se = FALSE)
> ##D 
> ##D ## standard error / confidence intervals computed using the influence function
> ##D ## (argument se = TRUE and B = 0)
> ##D ateFit2b <- ate(fitCR, data = dt, treatment = "X1", times = c(10,15,20),
> ##D                 cause = 1, se = TRUE, B = 0)
> ##D 
> ##D ## same as before with in addition the confidence bands for the ATE
> ##D ## (argument band = TRUE)
> ##D ateFit2c <- ate(fitCR, data = dt, treatment = "X1", times = c(10,15,20), 
> ##D                cause = 1, se = TRUE, band = TRUE, B = 0)
> ##D 
> ##D ## standard error / confidence intervals computed using 100 boostrap samples
> ##D ## (argument se = TRUE and B = 100) 
> ##D ateFit2d <- ate(fitCR, data = dt, treatment = "X1", times = c(10,15,20), 
> ##D                 cause = 1, se = TRUE, B = 100)
> ##D ## NOTE: for real applications 100 bootstrap samples is not enougth 
> ##D 
> ##D ## same but using 2 cpus for generating and analyzing the boostrap samples
> ##D ## (parallel computation, argument mc.cores = 2) 
> ##D ateFit2e <- ate(fitCR, data = dt, treatment = "X1", times = c(10,15,20), 
> ##D                 cause = 1, se = TRUE, B = 100, mc.cores = 2)
> ## End(Not run)
> 
> #### time-dependent covariates ###
> ## Not run: 
> ##D library(survival)
> ##D fit <- coxph(Surv(time, status) ~ celltype+karno + age + trt, veteran)
> ##D vet2 <- survSplit(Surv(time, status) ~., veteran,
> ##D                        cut=c(60, 120), episode ="timegroup")
> ##D fitTD <- coxph(Surv(tstart, time, status) ~ celltype+karno + age + trt,
> ##D                data= vet2,x=1)
> ##D set.seed(16)
> ##D resVet <- ate(fitTD,formula=Hist(entry=tstart,time=time,event=status)~1,
> ##D           data = vet2, treatment = "celltype", contrasts = NULL,
> ##D         times=5,verbose=1,
> ##D         landmark = c(0,30,60,90), cause = 1, B = 10, se = 1,
> ##D         band = FALSE, mc.cores=1)
> ##D resVet
> ## End(Not run)
> 
> ## Not run: 
> ##D set.seed(137)
> ##D d=sampleDataTD(127)
> ##D library(survival)
> ##D d[,status:=1*(event==1)]
> ##D d[,X3:=as.factor(X3)]
> ##D ## ignore competing risks
> ##D cox1TD <- coxph(Surv(start,time, status,type="counting") ~ X3+X5+X6+X8,
> ##D                 data=d, x = TRUE)
> ##D resTD1 <- ate(cox1TD,formula=Hist(entry=start,time=time,event=status)~1,
> ##D         data = d, treatment = "X3", contrasts = NULL,
> ##D         times=.5,verbose=1,
> ##D         landmark = c(0,0.5,1), B = 20, se = 1,
> ##D         band = FALSE, mc.cores=1)
> ##D resTD1
> ##D ## account for competing risks
> ##D cscTD <- CSC(Hist(time=time, event=event,entry=start) ~ X3+X5+X6+X8, data=d)
> ##D set.seed(16)
> ##D resTD <- ate(cscTD,formula=Hist(entry=start,time=time,event=event)~1,
> ##D         data = d, treatment = "X3", contrasts = NULL,
> ##D         times=.5,verbose=1,
> ##D         landmark = c(0,0.5,1), cause = 1, B = 20, se = 1,
> ##D         band = FALSE, mc.cores=1)
> ##D resTD
> ## End(Not run)
> 
> 
> 
> cleanEx()

detaching ‘package:prodlim’, ‘package:rms’, ‘package:SparseM’,
  ‘package:Hmisc’, ‘package:ggplot2’, ‘package:Formula’,
  ‘package:lattice’, ‘package:survival’

> nameEx("autoplot.Score")
> ### * autoplot.Score
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: autoplot.Score
> ### Title: ggplot AUC curve
> ### Aliases: autoplot.Score
> 
> ### ** Examples
> 
> library(survival)
> library(ggplot2)
> d=sampleData(100,outcome="survival")
> nd=sampleData(100,outcome="survival")
> f1=coxph(Surv(time,event)~X1+X6+X8,data=d,x=TRUE,y=TRUE)
> f2=coxph(Surv(time,event)~X2+X5+X9,data=d,x=TRUE,y=TRUE)
> xx=Score(list(f1,f2), formula=Surv(time,event)~1,
+ data=nd, metrics="auc", null.model=FALSE, times=seq(3:10))
> g <- autoplot(xx)
> print(g)
> aucgraph <- plotAUC(xx)
> plotAUC(xx,conf.int=TRUE)
> plotAUC(xx,which="contrasts")
> plotAUC(xx,which="contrasts",conf.int=TRUE)
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:ggplot2’, ‘package:survival’

> nameEx("autoplot.ate")
> ### * autoplot.ate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: autoplot.ate
> ### Title: Plot Average Risks
> ### Aliases: autoplot.ate
> 
> ### ** Examples
> 
> ## Not run: 
> ##D library(survival)
> ##D library(rms)
> ##D library(ggplot2)
> ##D #### simulate data ####
> ##D n <- 1e2
> ##D set.seed(10)
> ##D dtS <- sampleData(n,outcome="survival")
> ##D 
> ##D 
> ##D #### Cox model ####
> ##D fit <- cph(formula = Surv(time,event)~ X1+X2,data=dtS,y=TRUE,x=TRUE)
> ##D 
> ##D #### Average treatment effect ####
> ##D seqTimes <- sort(unique(fit$y[,1]))
> ##D seqTimes5 <- seqTimes[seqTimes>5 & seqTimes<10]
> ##D ateFit <- ate(fit, data = dtS, treatment = "X1", contrasts = NULL,
> ##D               times = seqTimes, B = 0, band = TRUE, nsim.band = 500, y = TRUE,
> ##D               mc.cores=1)
> ##D 
> ##D #### display #### 
> ##D ggplot2::autoplot(ateFit)
> ##D 
> ##D outGG <- autoplot(ateFit, band = TRUE, ci = TRUE, alpha = 0.1)
> ##D dd <- as.data.frame(outGG$data[treatment == 0])
> ##D outGG$plot + facet_wrap(~treatment, labeller = label_both)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("autoplot.predictCSC")
> ### * autoplot.predictCSC
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: autoplot.predictCSC
> ### Title: Plot Predictions From a Cause-specific Cox Proportional Hazard
> ###   Regression
> ### Aliases: autoplot.predictCSC
> 
> ### ** Examples
> 
> library(survival)
> library(rms)
Loading required package: Hmisc
Loading required package: lattice
Loading required package: Formula
Loading required package: ggplot2

Attaching package: ‘Hmisc’

The following objects are masked from ‘package:base’:

    format.pval, units

Loading required package: SparseM

Attaching package: ‘SparseM’

The following object is masked from ‘package:base’:

    backsolve

> library(ggplot2)
> library(prodlim)
> #### simulate data ####
> set.seed(10)
> d <- sampleData(1e2, outcome = "competing.risks")
> 
> #### CSC model ####
> m.CSC <- CSC(Hist(time,event)~ X1 + X2 + X6, data = d)
> 
> pred.CSC <- predict(m.CSC, newdata = d[1:2,], time = 1:5, cause = 1)#'
> autoplot(pred.CSC)
> 
> 
> #### stratified CSC model ####
> m.SCSC <- CSC(Hist(time,event)~ strata(X1) + strata(X2) + X6,
+               data = d)
> pred.SCSC <- predict(m.SCSC, time = 1:3, newdata = d[1:4,],
+                      cause = 1, keep.newdata = TRUE, keep.strata = TRUE)
> autoplot(pred.SCSC, group.by = "strata")
> 
> 
> 
> cleanEx()

detaching ‘package:prodlim’, ‘package:rms’, ‘package:SparseM’,
  ‘package:Hmisc’, ‘package:ggplot2’, ‘package:Formula’,
  ‘package:lattice’, ‘package:survival’

> nameEx("autoplot.predictCox")
> ### * autoplot.predictCox
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: autoplot.predictCox
> ### Title: Plot Predictions From a Cox Model
> ### Aliases: autoplot.predictCox
> 
> ### ** Examples
> 
> library(survival)
> library(ggplot2)
> 
> #### simulate data ####
> set.seed(10)
> d <- sampleData(1e2, outcome = "survival")
> 
> #### Cox model ####
> m.cox <- coxph(Surv(time,event)~ X1 + X2 + X3,
+                 data = d, x = TRUE, y = TRUE)
> 
> ## display baseline hazard
> e.basehaz <- predictCox(m.cox)
> 
> autoplot(e.basehaz, type = "cumhazard")
> 
> ## display predicted survival
> pred.cox <- predictCox(m.cox, newdata = d[1:4,],
+   times = 1:5, type = "survival", keep.newdata = TRUE)
> autoplot(pred.cox)
> autoplot(pred.cox, group.by = "covariates")
> autoplot(pred.cox, group.by = "covariates", reduce.data = TRUE)
> 
> ## predictions with confidence interval/bands
> pred.cox <- predictCox(m.cox, newdata = d[1,,drop=FALSE],
+   times = 1:5, type = "survival", band = TRUE, se = TRUE, keep.newdata = TRUE)
> autoplot(pred.cox, ci = TRUE, band = TRUE)
> autoplot(pred.cox, ci = TRUE, band = TRUE, alpha = 0.1)
> 
> #### Stratified Cox model ####
> m.cox.strata <- coxph(Surv(time,event)~ strata(X1) + strata(X2) + X3 + X6,
+                       data = d, x = TRUE, y = TRUE)
> 
> pred.cox.strata <- predictCox(m.cox.strata, newdata = d[1:5,,drop=FALSE],
+                               time = 1:5, keep.newdata = TRUE)
> 
> ## display
> res <- autoplot(pred.cox.strata, type = "survival", group.by = "strata")
> 
> ## customize display
> res$plot + facet_wrap(~strata, labeller = label_both)
> res$plot %+% res$data[strata == "0, 1"]
> 
> 
> 
> cleanEx()

detaching ‘package:ggplot2’, ‘package:survival’

> nameEx("boot2pvalue")
> ### * boot2pvalue
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: boot2pvalue
> ### Title: Compute the p.value from the distribution under H1
> ### Aliases: boot2pvalue
> 
> ### ** Examples
> 
> set.seed(10)
> 
> #### no effect ####
> x <- rnorm(1e3) 
> boot2pvalue(x, null = 0, estimate = mean(x), alternative = "two.sided")
Warning in boot2pvalue(x, null = 0, estimate = mean(x), alternative = "two.sided") :
  incorrect convergence of the algorithm finding the critical quantile 
p-value may not be reliable 

[1] 0.999
> ## expected value of 1
> boot2pvalue(x, null = 0, estimate = mean(x), alternative = "greater")
[1] 0.5
> ## expected value of 0.5
> boot2pvalue(x, null = 0, estimate = mean(x), alternative = "less")
[1] 0.5
> ## expected value of 0.5
> 
> #### positive effect ####
> x <- rnorm(1e3, mean = 1) 
> boot2pvalue(x, null = 0, estimate = 1, alternative = "two.sided")
[1] 0.336
> ## expected value of 0.32 = 2*pnorm(q = 0, mean = -1) = 2*mean(x<=0)
> boot2pvalue(x, null = 0, estimate = 1, alternative = "greater")  
[1] 0.168
> ## expected value of 0.16 = pnorm(q = 0, mean = 1) = mean(x<=0)
> boot2pvalue(x, null = 0, estimate = 1, alternative = "less")
[1] 0.832
> ## expected value of 0.84 = 1-pnorm(q = 0, mean = 1) = mean(x>=0)
> 
> #### negative effect ####
> x <- rnorm(1e3, mean = -1) 
> boot2pvalue(x, null = 0, estimate = -1, alternative = "two.sided") 
[1] 0.301
> ## expected value of 0.32 = 2*(1-pnorm(q = 0, mean = -1)) = 2*mean(x>=0)
> boot2pvalue(x, null = 0, estimate = -1, alternative = "greater")
[1] 0.849
> ## expected value of 0.84 = pnorm(q = 0, mean = -1) = mean(x<=0)
> boot2pvalue(x, null = 0, estimate = -1, alternative = "less") # pnorm(q = 0, mean = -1)
[1] 0.151
> ## expected value of 0.16 = 1-pnorm(q = 0, mean = -1) = mean(x>=0)
> 
> 
> 
> cleanEx()
> nameEx("boxplot.Score")
> ### * boxplot.Score
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: boxplot.Score
> ### Title: Boxplot risk quantiles
> ### Aliases: boxplot.Score
> 
> ### ** Examples
> 
> # binary outcome
> library(data.table)
> library(prodlim)
> db=sampleData(40,outcome="binary")
> fitconv=glm(Y~X3+X5,data=db,family=binomial)
> fitnew=glm(Y~X1+X3+X5+X6+X7,data=db,family=binomial)
> x=Score(list(new=fitnew,conv=fitconv),
+         formula=Y~1,contrasts=list(c(2,1)),
+                data=db,plots="box",null.model=FALSE)
> boxplot(x)
> 
> # survival outcome
> library(survival)
> ds=sampleData(40,outcome="survival")
> fit=coxph(Surv(time,event)~X6+X9,data=ds,x=TRUE,y=TRUE)
> ## Not run: 
> ##D  
> ##D scoreobj=Score(list("Cox"=fit),
> ##D                 formula=Hist(time,event)~1, data=ds,
> ##D                 metrics=NULL, plots="box",
> ##D                 times=c(1,5),null.model=FALSE)
> ##D boxplot(scoreobj,timepoint=5)
> ##D boxplot(scoreobj,timepoint=1)
> ##D 
> ## End(Not run)
> 
> # competing risks outcome
> library(survival)
> data(Melanoma, package = "riskRegression")
> fit = CSC(Hist(time,event,cens.code="censored")~invasion+age+sex,data=Melanoma)
Warning in FUN(X[[i]], ...) :
  Variables named status in data will be ignored.
Warning in FUN(X[[i]], ...) :
  Variables named status in data will be ignored.
> scoreobj=Score(list("CSC"=fit),
+                formula=Hist(time,event,cens.code="censored")~1,
+                data=Melanoma,plots="box",times=5*365.25,null.model=FALSE)
> par(mar=c(4,12,4,4))
> boxplot(scoreobj,timepoint=5*365.25)
> 
> # more than 2 competing risks
> m=lava::lvm(~X1+X2+X3)
> lava::distribution(m, "eventtime1") <- lava::coxWeibull.lvm(scale = 1/100)
> lava::distribution(m, "eventtime2") <- lava::coxWeibull.lvm(scale = 1/100)
> lava::distribution(m, "eventtime3") <- lava::coxWeibull.lvm(scale = 1/100)
> lava::distribution(m, "censtime") <- lava::coxWeibull.lvm(scale = 1/100)
> lava::regression(m,eventtime2~X3)=1.3
> m <- lava::eventTime(m,
+ time ~ min(eventtime1 = 1, eventtime2 = 2, eventtime3 = 3, censtime = 0), "event")
> set.seed(101)
> dcr=as.data.table(lava::sim(m,101))
> fit = CSC(Hist(time,event)~X1+X2+X3,data=dcr)
> scoreobj=Score(list("my model"=fit),
+                formula=Hist(time,event)~1,
+                data=dcr,plots="box",times=5,null.model=FALSE)
> boxplot(scoreobj)
> 
> 
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()

detaching ‘package:survival’, ‘package:prodlim’, ‘package:data.table’

> nameEx("colCenter_cpp")
> ### * colCenter_cpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: colCenter_cpp
> ### Title: Apply - by column
> ### Aliases: colCenter_cpp
> 
> ### ** Examples
> 
> x <- matrix(1,6,5)
> sweep(x, MARGIN = 1, FUN = "-", STATS = 1:6)
     [,1] [,2] [,3] [,4] [,5]
[1,]    0    0    0    0    0
[2,]   -1   -1   -1   -1   -1
[3,]   -2   -2   -2   -2   -2
[4,]   -3   -3   -3   -3   -3
[5,]   -4   -4   -4   -4   -4
[6,]   -5   -5   -5   -5   -5
> colCenter_cpp(x, 1:6 )
     [,1] [,2] [,3] [,4] [,5]
[1,]    0    0    0    0    0
[2,]   -1   -1   -1   -1   -1
[3,]   -2   -2   -2   -2   -2
[4,]   -3   -3   -3   -3   -3
[5,]   -4   -4   -4   -4   -4
[6,]   -5   -5   -5   -5   -5
> 
> 
> 
> cleanEx()
> nameEx("colCumProd")
> ### * colCumProd
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: colCumProd
> ### Title: Apply cumprod in each column
> ### Aliases: colCumProd
> 
> ### ** Examples
> 
> x <- matrix(1:8,ncol=2)
> colCumProd(x)
     [,1] [,2]
[1,]    1    5
[2,]    2   30
[3,]    6  210
[4,]   24 1680
> 
> 
> 
> cleanEx()
> nameEx("colCumSum")
> ### * colCumSum
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: colCumSum
> ### Title: Apply cumsum in each column
> ### Aliases: colCumSum
> 
> ### ** Examples
> 
> x <- matrix(1:8,ncol=2)
> colCumSum(x)
     [,1] [,2]
[1,]    1    5
[2,]    3   11
[3,]    6   18
[4,]   10   26
> 
> 
> 
> cleanEx()
> nameEx("colMultiply_cpp")
> ### * colMultiply_cpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: colMultiply_cpp
> ### Title: Apply * by column
> ### Aliases: colMultiply_cpp
> 
> ### ** Examples
> 
> x <- matrix(1,6,5)
> sweep(x, MARGIN = 1, FUN = "*", STATS = 1:6)
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    1    1    1    1
[2,]    2    2    2    2    2
[3,]    3    3    3    3    3
[4,]    4    4    4    4    4
[5,]    5    5    5    5    5
[6,]    6    6    6    6    6
> colMultiply_cpp(x, 1:6 )
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    1    1    1    1
[2,]    2    2    2    2    2
[3,]    3    3    3    3    3
[4,]    4    4    4    4    4
[5,]    5    5    5    5    5
[6,]    6    6    6    6    6
> 
> 
> 
> cleanEx()
> nameEx("colScale_cpp")
> ### * colScale_cpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: colScale_cpp
> ### Title: Apply / by column
> ### Aliases: colScale_cpp
> 
> ### ** Examples
> 
> x <- matrix(1,6,5)
> sweep(x, MARGIN = 1, FUN = "/", STATS = 1:6)
          [,1]      [,2]      [,3]      [,4]      [,5]
[1,] 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000
[2,] 0.5000000 0.5000000 0.5000000 0.5000000 0.5000000
[3,] 0.3333333 0.3333333 0.3333333 0.3333333 0.3333333
[4,] 0.2500000 0.2500000 0.2500000 0.2500000 0.2500000
[5,] 0.2000000 0.2000000 0.2000000 0.2000000 0.2000000
[6,] 0.1666667 0.1666667 0.1666667 0.1666667 0.1666667
> colScale_cpp(x, 1:6 )
          [,1]      [,2]      [,3]      [,4]      [,5]
[1,] 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000
[2,] 0.5000000 0.5000000 0.5000000 0.5000000 0.5000000
[3,] 0.3333333 0.3333333 0.3333333 0.3333333 0.3333333
[4,] 0.2500000 0.2500000 0.2500000 0.2500000 0.2500000
[5,] 0.2000000 0.2000000 0.2000000 0.2000000 0.2000000
[6,] 0.1666667 0.1666667 0.1666667 0.1666667 0.1666667
> 
> 
> 
> cleanEx()
> nameEx("colSumsCrossprod")
> ### * colSumsCrossprod
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: colSumsCrossprod
> ### Title: Apply crossprod and colSums
> ### Aliases: colSumsCrossprod
> 
> ### ** Examples
> 
> x <- matrix(1:8,ncol=2)
> y <- matrix(1:16,ncol=8)
> colSumsCrossprod(x,y,0)
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
[1,]   62  134  206  278  350  422  494  566
> 
> x <- matrix(1:8,ncol=2)
> y <- matrix(1:16,ncol=2)
> colSumsCrossprod(x,y,1)
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
[1,]  244  280  316  352  388  424  460  496
> 
> 
> 
> cleanEx()
> nameEx("confint.ate")
> ### * confint.ate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: confint.ate
> ### Title: Confidence Intervals and Confidence Bands for the Predicted
> ###   Absolute Risk (Cumulative Incidence Function)
> ### Aliases: confint.ate
> 
> ### ** Examples
> 
> library(survival)
> library(data.table)
> 
> ## ## generate data ####
> set.seed(10)
> d <- sampleData(70,outcome="survival")
> d[, X1 := paste0("T",rbinom(.N, size = 2, prob = c(0.51)))]
> ## table(d$X1)
> 
> #### stratified Cox model ####
> fit <- coxph(Surv(time,event)~X1 + strata(X2) + X6,
+              data=d, ties="breslow", x = TRUE, y = TRUE)
> 
> #### average treatment effect ####
> fit.ate <- ate(fit, treatment = "X1", times = 1:3, data = d,
+                se = TRUE, iid = TRUE, band = TRUE)
     Calculation of the average treatment effect 

 - Estimator         : Gformula
 - Treatment variable: X1 (3 levels)
 - Event variable    : event (cause: 1, censoring: 0)
 - Time variable     : time

 - Prepare influence function: outcome done 
 - Point estimation: done 
 - Functional delta method: done
 - Confidence intervals: done
> print(fit.ate, type = "meanRisk")
    Estimation of the Average Treatment Effect 

Average risk: between time zero and 'time',
Warning in `[.data.table`(dt.tempo, , `:=`(c("p.value"), NULL)) :
  Column 'p.value' does not exist to remove
   treatment time average risk     se quantileBand   conf.interval
1:        T0    1       0.0339 0.0256         2.20 [0.000 ; 0.084]
2:        T1    1       0.0472 0.0279         2.27 [0.000 ; 0.102]
3:        T2    1       0.0420 0.0233         2.31 [0.000 ; 0.088]
4:        T0    2       0.1352 0.0558         2.20 [0.026 ; 0.244]
5:        T1    2       0.1826 0.0596         2.27 [0.066 ; 0.299]
6:        T2    2       0.1645 0.0463         2.31 [0.074 ; 0.255]
7:        T0    3       0.1703 0.0626         2.20 [0.048 ; 0.293]
8:        T1    3       0.2267 0.0657         2.27 [0.098 ; 0.356]
9:        T2    3       0.2054 0.0529         2.31 [0.102 ; 0.309]
         conf.band
1: [0.000 ; 0.090]
2: [0.000 ; 0.111]
3: [0.000 ; 0.096]
4: [0.013 ; 0.258]
5: [0.047 ; 0.318]
6: [0.057 ; 0.272]
7: [0.033 ; 0.308]
8: [0.077 ; 0.376]
9: [0.083 ; 0.328]

> dt.ate <- as.data.table(fit.ate)
> 
> ## manual calculation of se
> dd <- copy(d)
> dd$X1 <- rep(factor("T0", levels = paste0("T",0:2)), NROW(dd))
> out <- predictCox(fit, newdata = dd, se = TRUE, times = 1:3, average.iid = TRUE)
> term1 <- -out$survival.average.iid
> term2 <- sweep(1-out$survival, MARGIN = 2, FUN = "-", STATS = colMeans(1-out$survival))
> sqrt(colSums((term1 + term2/NROW(d))^2)) 
[1] 0.02557002 0.05576405 0.06256730
> ## fit.ate$meanRisk[treatment=="T0",meanRisk.se]
> 
> ## note
> out2 <- predictCox(fit, newdata = dd, se = TRUE, times = 1:3, iid = TRUE)
> mean(out2$survival.iid[,1,1])
[1] -0.0003529296
> out$survival.average.iid[1,1]
[1] -0.0003529296
> 
> ## check confidence intervals (no transformation)
> dt.ate[,.(lower = pmax(0,value + qnorm(0.025) * se),
+           lower2 = lower,
+           upper = value + qnorm(0.975) * se,
+           upper2 = upper)]
         lower      lower2      upper     upper2
 1: 0.00000000  0.00000000 0.08401352 0.08401352
 2: 0.00000000  0.00000000 0.10199266 0.10199266
 3: 0.00000000  0.00000000 0.08763162 0.08763162
 4: 0.02590437  0.02590437 0.24449544 0.24449544
 5: 0.06587254  0.06587254 0.29931345 0.29931345
 6: 0.07373281  0.07373281 0.25532659 0.25532659
 7: 0.04767637  0.04767637 0.29293567 0.29293567
 8: 0.09787653  0.09787653 0.35557496 0.35557496
 9: 0.10169224  0.10169224 0.30914481 0.30914481
10: 0.00000000 -0.01843023 0.04508014 0.04508014
11: 0.00000000 -0.07044632 0.16523250 0.16523250
12: 0.00000000 -0.08418721 0.19702666 0.19702666
13: 0.00000000 -0.01583434 0.03212551 0.03212551
14: 0.00000000 -0.06563720 0.12429679 0.12429679
15: 0.00000000 -0.08028787 0.15051289 0.15051289
16: 0.00000000 -0.03892565 0.02856692 0.02856692
17: 0.00000000 -0.13355386 0.09742727 0.09742727
18: 0.00000000 -0.15680088 0.11418644 0.11418644
19: 0.21268856  0.21268856 2.57350940 2.57350940
20: 0.31415598  0.31415598 2.38692575 2.38692575
21: 0.35840663  0.35840663 2.30416217 2.30416217
22: 0.32511683  0.32511683 2.15548849 2.15548849
23: 0.39528481  0.39528481 2.03858823 2.03858823
24: 0.42753998  0.42753998 1.98480606 1.98480606
25: 0.23798475  0.23798475 1.54265349 1.54265349
26: 0.31071769  0.31071769 1.49142922 1.49142922
27: 0.34410983  0.34410983 1.46793427 1.46793427
         lower      lower2      upper     upper2
> 
> ## add confidence intervals computed on the log-log scale
> ## and backtransformed
> outCI <- confint(fit.ate,
+                  meanRisk.transform = "loglog", diffRisk.transform = "atanh",
+                  ratioRisk.transform = "log")
> print(outCI, type = "meanRisk")
    Estimation of the Average Treatment Effect 

Average risk: between time zero and 'time',
   treatment time average risk     se quantileBand   conf.interval
1:        T0    1       0.0339 0.0256         2.25 [0.005 ; 0.112]
2:        T1    1       0.0472 0.0279         2.28 [0.012 ; 0.124]
3:        T2    1       0.0420 0.0233         2.28 [0.012 ; 0.105]
4:        T0    2       0.1352 0.0558         2.25 [0.050 ; 0.263]
5:        T1    2       0.1826 0.0596         2.28 [0.084 ; 0.311]
6:        T2    2       0.1645 0.0463         2.28 [0.086 ; 0.265]
7:        T0    3       0.1703 0.0626         2.25 [0.070 ; 0.308]
8:        T1    3       0.2267 0.0657         2.28 [0.113 ; 0.364]
9:        T2    3       0.2054 0.0529         2.28 [0.113 ; 0.317]
         conf.band
1: [0.004 ; 0.129]
2: [0.009 ; 0.141]
3: [0.009 ; 0.119]
4: [0.041 ; 0.284]
5: [0.072 ; 0.333]
6: [0.076 ; 0.282]
7: [0.059 ; 0.330]
8: [0.099 ; 0.387]
9: [0.101 ; 0.336]

> 
> dt.ate[type == "ate", newse := se/(value*log(value))]
> dt.ate[type == "ate", .(lower = exp(-exp(log(-log(value)) - 1.96 * newse)),
+                         upper = exp(-exp(log(-log(value)) + 1.96 * newse)))]
         lower     upper
1: 0.005308092 0.1123030
2: 0.011517821 0.1239456
3: 0.011538684 0.1053196
4: 0.049930563 0.2629084
5: 0.084038215 0.3110947
6: 0.086275187 0.2646901
7: 0.070036723 0.3077237
8: 0.113440244 0.3635412
9: 0.113322713 0.3165183
> 
> 
> 
> cleanEx()

detaching ‘package:data.table’, ‘package:survival’

> nameEx("confint.predictCSC")
> ### * confint.predictCSC
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: confint.predictCSC
> ### Title: Confidence Intervals and Confidence Bands for the Predicted
> ###   Absolute Risk (Cumulative Incidence Function)
> ### Aliases: confint.predictCSC
> 
> ### ** Examples
> 
> library(survival)
> library(prodlim)
> #### generate data ####
> set.seed(10)
> d <- sampleData(100) 
> 
> #### estimate a stratified CSC model ###
> fit <- CSC(Hist(time,event)~ X1 + strata(X2) + X6, data=d)
> 
> #### compute individual specific risks
> fit.pred <- predict(fit, newdata=d[1:3], times=c(3,8), cause = 1,
+                     se = TRUE, iid = TRUE, band = TRUE)
> fit.pred
   observation X1   X6 times strata absRisk absRisk.se absRisk.lower
1:           1  1 30.8     3   X2=1   0.138     0.0785        0.0311
2:           2  0 66.3     3   X2=1   0.456     0.1247        0.2114
3:           3  0 77.6     3   X2=1   0.799     0.1285        0.4007
4:           1  1 30.8     8   X2=1   0.298     0.1365        0.0788
5:           2  0 66.3     8   X2=1   0.803     0.0900        0.5503
6:           3  0 77.6     8   X2=1   0.954     0.0659        0.4310
   absRisk.upper absRisk.quantileBand absRisk.lowerBand absRisk.upperBand
1:         0.324                 2.15            0.0255             0.344
2:         0.673                 2.21            0.1832             0.695
3:         0.946                 2.15            0.3498             0.953
4:         0.562                 2.15            0.0649             0.585
5:         0.923                 2.21            0.5067             0.932
6:         0.997                 2.15            0.3266             0.998
> 
> ## check confidence intervals
> newse <- fit.pred$absRisk.se/(-fit.pred$absRisk*log(fit.pred$absRisk))
> cbind(lower = as.double(exp(-exp(log(-log(fit.pred$absRisk)) + 1.96 * newse))),
+       upper = as.double(exp(-exp(log(-log(fit.pred$absRisk)) - 1.96 * newse)))
+ )
          lower     upper
[1,] 0.03106980 0.3237727
[2,] 0.21142317 0.6725332
[3,] 0.40068902 0.9463311
[4,] 0.07874874 0.5616676
[5,] 0.55031414 0.9226697
[6,] 0.43098190 0.9973992
> 
> #### compute confidence intervals without transformation
> confint(fit.pred, absRisk.transform = "none")
   observation X1   X6 times strata absRisk absRisk.se absRisk.lower
1:           1  1 30.8     3   X2=1   0.138     0.0785        0.0000
2:           2  0 66.3     3   X2=1   0.456     0.1247        0.2116
3:           3  0 77.6     3   X2=1   0.799     0.1285        0.5469
4:           1  1 30.8     8   X2=1   0.298     0.1365        0.0305
5:           2  0 66.3     8   X2=1   0.803     0.0900        0.6267
6:           3  0 77.6     8   X2=1   0.954     0.0659        0.8252
   absRisk.upper absRisk.quantileBand absRisk.lowerBand absRisk.upperBand
1:         0.292                 2.14           0.00000             0.306
2:         0.700                 2.23           0.17842             0.734
3:         1.000                 2.17           0.51970             1.000
4:         0.565                 2.14           0.00656             0.589
5:         0.980                 2.23           0.60269             1.000
6:         1.000                 2.17           0.81125             1.000
> cbind(lower = as.double(fit.pred$absRisk - 1.96 * fit.pred$absRisk.se),
+       upper = as.double(fit.pred$absRisk + 1.96 * fit.pred$absRisk.se)
+ )
           lower     upper
[1,] -0.01553676 0.2920606
[2,]  0.21161883 0.7004983
[3,]  0.54689863 1.0507549
[4,]  0.03045984 0.5654551
[5,]  0.62665840 0.9795842
[6,]  0.82518445 1.0833380
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:prodlim’, ‘package:survival’

> nameEx("confint.predictCox")
> ### * confint.predictCox
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: confint.predictCox
> ### Title: Confidence Intervals and Confidence Bands for the predicted
> ###   Survival/Cumulative Hazard
> ### Aliases: confint.predictCox
> 
> ### ** Examples
> 
> library(survival)
> 
> #### generate data ####
> set.seed(10)
> d <- sampleData(40,outcome="survival") 
> 
> #### estimate a stratified Cox model ####
> fit <- coxph(Surv(time,event)~X1 + strata(X2) + X6,
+              data=d, ties="breslow", x = TRUE, y = TRUE)
> 
> #### compute individual specific survival probabilities  
> fit.pred <- predictCox(fit, newdata=d[1:3], times=c(3,8), type = "survival",
+                        se = TRUE, iid = TRUE, band = TRUE)
> fit.pred
   observation times strata survival survival.se survival.lower survival.upper
1:           1     3      0    0.830      0.0598          0.672          0.917
2:           2     3      0    0.878      0.0510          0.732          0.947
3:           3     3      0    0.975      0.0194          0.888          0.995
4:           1     8      0    0.441      0.1062          0.233          0.631
5:           2     8      0    0.564      0.1131          0.320          0.750
6:           3     8      0    0.894      0.0692          0.648          0.972
   survival.quantileBand survival.lowerBand survival.upperBand
1:                  2.24              0.642              0.925
2:                  2.22              0.704              0.953
3:                  2.13              0.873              0.995
4:                  2.24              0.205              0.654
5:                  2.22              0.287              0.769
6:                  2.13              0.613              0.975
> 
> ## check standard error
> sqrt(rowSums(fit.pred$survival.iid[1,,]^2)) ## se for individual 1
[1] 0.05983286 0.10622873
> 
> ## check confidence interval
> newse <- fit.pred$survival.se/(-fit.pred$survival*log(fit.pred$survival))
> cbind(lower = as.double(exp(-exp(log(-log(fit.pred$survival)) + 1.96 * newse))),
+       upper = as.double(exp(-exp(log(-log(fit.pred$survival)) - 1.96 * newse)))
+ )
         lower     upper
[1,] 0.6720145 0.9166403
[2,] 0.7317857 0.9473215
[3,] 0.8882076 0.9945995
[4,] 0.2325654 0.6310395
[5,] 0.3204751 0.7495790
[6,] 0.6477553 0.9717133
> 
> #### compute confidence intervals without transformation
> confint(fit.pred, survival.transform = "none")
   observation times strata survival survival.se survival.lower survival.upper
1:           1     3      0    0.830      0.0598          0.713          0.948
2:           2     3      0    0.878      0.0510          0.778          0.978
3:           3     3      0    0.975      0.0194          0.937          1.000
4:           1     8      0    0.441      0.1062          0.232          0.649
5:           2     8      0    0.564      0.1131          0.342          0.786
6:           3     8      0    0.894      0.0692          0.759          1.000
   survival.quantileBand survival.lowerBand survival.upperBand
1:                  2.24              0.697              0.964
2:                  2.20              0.766              0.991
3:                  2.10              0.934              1.000
4:                  2.24              0.203              0.678
5:                  2.20              0.315              0.813
6:                  2.10              0.749              1.000
> cbind(lower = as.double(fit.pred$survival - 1.96 * fit.pred$survival.se),
+       upper = as.double(fit.pred$survival + 1.96 * fit.pred$survival.se)
+ )
         lower     upper
[1,] 0.7130004 0.9475453
[2,] 0.7780635 0.9781347
[3,] 0.9368629 1.0130999
[4,] 0.2324617 0.6488784
[5,] 0.3422163 0.7857635
[6,] 0.7587567 1.0300007
> 
> 
> 
> 
> cleanEx()

detaching ‘package:survival’

> nameEx("getSplitMethod")
> ### * getSplitMethod
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getSplitMethod
> ### Title: Input for data splitting algorithms
> ### Aliases: getSplitMethod
> 
> ### ** Examples
> 
> # 3-fold crossvalidation
> getSplitMethod("cv3",B=4,N=37)
$name
[1] "3-fold cross-validation"

$internal.name
[1] "crossval"

$index
      [,1] [,2] [,3] [,4]
 [1,]    1    2    3    2
 [2,]    1    3    3    2
 [3,]    1    1    1    1
 [4,]    2    3    2    3
 [5,]    2    1    3    1
 [6,]    3    3    1    2
 [7,]    3    2    2    3
 [8,]    1    2    1    2
 [9,]    3    1    1    1
[10,]    3    3    3    3
[11,]    1    1    2    2
[12,]    1    1    1    3
[13,]    1    3    2    2
[14,]    3    1    1    2
[15,]    2    1    2    1
[16,]    1    1    3    3
[17,]    3    2    2    3
[18,]    3    2    3    1
[19,]    2    3    1    3
[20,]    1    2    1    3
[21,]    3    3    3    1
[22,]    3    1    2    2
[23,]    1    2    1    2
[24,]    2    2    2    2
[25,]    2    1    3    1
[26,]    2    2    2    1
[27,]    2    3    2    3
[28,]    1    3    2    2
[29,]    3    1    3    1
[30,]    3    1    1    3
[31,]    2    2    3    1
[32,]    1    2    2    1
[33,]    1    3    3    3
[34,]    2    1    3    1
[35,]    2    3    1    3
[36,]    3    2    1    2
[37,]    2    3    1    1

$k
[1] 3

$B
[1] 4

$M
[1] 37

$N
[1] 37

attr(,"class")
[1] "split.method"
> 
> # bootstrap with replacement
> getSplitMethod("loob",B=4,N=37)
$name
[1] "LeaveOneOutBoot"

$internal.name
[1] "LeaveOneOutBoot"

$index
      [,1] [,2] [,3] [,4]
 [1,]    1    1    1    1
 [2,]    1    2    2    4
 [3,]    2    4    3    4
 [4,]    2    6    4    5
 [5,]    3    7    7    6
 [6,]    5    7    8    9
 [7,]    9    8    9    9
 [8,]    9    8   10   10
 [9,]   10    8   11   11
[10,]   11    9   12   13
[11,]   11   13   14   14
[12,]   12   14   14   16
[13,]   13   15   15   16
[14,]   14   16   15   17
[15,]   15   20   16   17
[16,]   15   21   17   19
[17,]   16   22   18   23
[18,]   16   24   20   23
[19,]   17   25   20   24
[20,]   17   26   22   25
[21,]   19   27   24   26
[22,]   19   27   25   26
[23,]   20   28   26   26
[24,]   24   28   27   26
[25,]   26   29   28   27
[26,]   28   29   28   28
[27,]   29   30   29   29
[28,]   31   31   29   30
[29,]   31   31   29   33
[30,]   32   35   31   33
[31,]   34   35   32   33
[32,]   34   36   33   34
[33,]   35   36   33   34
[34,]   35   36   34   35
[35,]   37   36   34   35
[36,]   37   37   37   37
[37,]   37   37   37   37

$k
NULL

$B
[1] 4

$M
[1] 37

$N
[1] 37

attr(,"class")
[1] "split.method"
> 
> # bootstrap without replacement
> getSplitMethod("loob",B=4,N=37,M=20)
$name
[1] "LeaveOneOutBoot"

$internal.name
[1] "LeaveOneOutBoot"

$index
      [,1] [,2] [,3] [,4]
 [1,]    1    4    1    1
 [2,]    3    5    2    2
 [3,]    4    7    6    4
 [4,]    5    9    7    5
 [5,]    8   12    8    8
 [6,]    9   15   13   10
 [7,]   10   17   14   12
 [8,]   11   18   15   13
 [9,]   12   19   17   15
[10,]   13   20   18   20
[11,]   19   22   21   23
[12,]   20   23   24   24
[13,]   21   25   25   25
[14,]   22   27   26   28
[15,]   25   31   27   31
[16,]   28   32   30   32
[17,]   30   34   31   33
[18,]   32   35   32   34
[19,]   34   36   36   35
[20,]   35   37   37   37

$k
NULL

$B
[1] 4

$M
[1] 20

$N
[1] 37

attr(,"class")
[1] "split.method"
> 
> 
> 
> 
> cleanEx()
> nameEx("iidCox")
> ### * iidCox
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: iidCox
> ### Title: Extract iid decomposition from a Cox model
> ### Aliases: iidCox iidCox.coxph iidCox.cph iidCox.phreg
> ###   iidCox.CauseSpecificCox
> 
> ### ** Examples
> 
> library(survival)
> library(data.table)
> library(prodlim)
> set.seed(10)
> d <- sampleData(100, outcome = "survival")[,.(eventtime,event,X1,X6)]
> setkey(d, eventtime)
> 
> m.cox <- coxph(Surv(eventtime, event) ~ X1+X6, data = d, y = TRUE, x = TRUE)
> system.time(IF.cox <- iidCox(m.cox))
   user  system elapsed 
  0.008   0.000   0.008 
> system.time(IF.cox_approx <- iidCox(m.cox, store.iid = "approx"))
   user  system elapsed 
  0.006   0.000   0.006 
> 
> 
> IF.cox.all <- iidCox(m.cox, tau.hazard = sort(unique(c(7,d$eventtime))))
> IF.cox.beta <- iidCox(m.cox, baseline.iid = FALSE)
> 
> 
> 
> 
> cleanEx()

detaching ‘package:prodlim’, ‘package:data.table’, ‘package:survival’

> nameEx("influenceTest")
> ### * influenceTest
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: influenceTest
> ### Title: Influence test [Experimental!!]
> ### Aliases: influenceTest influenceTest.list influenceTest.default
> 
> ### ** Examples
> 
> library(lava)
> library(survival)
> library(prodlim)
> library(data.table)
> n <- 100
> 
> #### Under H1
> set.seed(1)
> newdata <- data.frame(X1=0:1)
> 
> ## simulate non proportional hazard using lava
> m <- lvm()
> regression(m) <- y ~ 1
> regression(m) <- s ~ exp(-2*X1)
> distribution(m,~X1) <- binomial.lvm()
> distribution(m,~cens) <- coxWeibull.lvm(scale=1)
> distribution(m,~y) <- coxWeibull.lvm(scale=1,shape=~s)
> eventTime(m) <- eventtime ~ min(y=1,cens=0)
> d <- as.data.table(sim(m,n))
> setkey(d, eventtime)
> 
> ## fit cox models
> m.cox <- coxph(Surv(eventtime, status) ~ X1, 
+                data = d, y = TRUE, x = TRUE)
> 
> mStrata.cox <- coxph(Surv(eventtime, status) ~ strata(X1), 
+                      data = d, y = TRUE, x = TRUE)
> 
> ## compare models
> # one time point
> outIF <- influenceTest(list(m.cox, mStrata.cox), 
+               type = "survival", newdata = newdata, times = 0.5)
> confint(outIF)
        Comparison of two estimates of the survival at time 0.5

model 1:
coxph(formula = Surv(eventtime, status) ~ X1, data = d, x = TRUE, 
    y = TRUE)
model 2:
coxph(formula = Surv(eventtime, status) ~ strata(X1), data = d, 
    x = TRUE, y = TRUE)
   X1 time difference     se                               conf.interval
1:  0  0.5    -0.0608 0.0270 [-0.113699154852329 ; -0.00787307258824682]
2:  1  0.5     0.0361 0.0241  [-0.0111131003191009 ; 0.0833881342370634]
   p.value quantileBand                                   conf.band
1:  0.0243         1.98 [-0.114287064066313 ; -0.00728516337426317]
2:  0.1339         1.98  [-0.0115297713326029 ; 0.0838048052505654]
>                                  
> # several timepoints
> outIF <- influenceTest(list(m.cox, mStrata.cox), 
+               type = "survival", newdata = newdata, times = c(0.5,1,1.5))
> confint(outIF)
        Comparison of two estimates of the survival at time 0.5 1 1.5

model 1:
coxph(formula = Surv(eventtime, status) ~ X1, data = d, x = TRUE, 
    y = TRUE)
model 2:
coxph(formula = Surv(eventtime, status) ~ strata(X1), data = d, 
    x = TRUE, y = TRUE)
   X1 time difference     se                               conf.interval
1:  0  0.5    -0.0608 0.0270 [-0.113699154852329 ; -0.00787307258824682]
2:  0  1.0     0.0539 0.0273  [0.000441392312159838 ; 0.107274038619528]
3:  0  1.5     0.0539 0.0273  [0.000441392312159838 ; 0.107274038619528]
4:  1  0.5     0.0361 0.0241  [-0.0111131003191009 ; 0.0833881342370634]
5:  1  1.0    -0.0626 0.0234  [-0.108505628220617 ; -0.0166462684257652]
6:  1  1.5    -0.0626 0.0234  [-0.108505628220617 ; -0.0166462684257652]
   p.value quantileBand                                   conf.band
1: 0.02435         2.16 [-0.119221507529816 ; -0.00235071991076024]
2: 0.04814         2.16  [-0.00513348618429857 ; 0.112848917115986]
3: 0.04814         2.16  [-0.00513348618429857 ; 0.112848917115986]
4: 0.13388         2.19  [-0.0166344490136629 ; 0.0889094829316254]
5: 0.00758         2.19  [-0.113872622193433 ; -0.0112792744529491]
6: 0.00758         2.19  [-0.113872622193433 ; -0.0112792744529491]
> 
> #### Under H0 (Cox) ####
> set.seed(1)
> ## simulate proportional hazard using lava
> m <- lvm()
> regression(m) <- y ~ 1
> distribution(m,~X1) <- binomial.lvm()
> distribution(m,~cens) <- coxWeibull.lvm()
> distribution(m,~y) <- coxWeibull.lvm()
> eventTime(m) <- eventtime ~ min(y=1,cens=0)
> d <- as.data.table(sim(m,n))
> setkey(d, eventtime)
> 
> ## fit cox models
> Utime <- sort(unique(d$eventtime))
> m.cox <- coxph(Surv(eventtime, status) ~ X1, 
+                data = d, y = TRUE, x = TRUE)
> 
> mStrata.cox <- coxph(Surv(eventtime, status) ~ strata(X1), 
+                      data = d, y = TRUE, x = TRUE)
> 
> p.cox <- predictCox(m.cox, newdata = newdata, time = Utime, type = "survival")
> p.coxStrata <- predictCox(mStrata.cox, newdata = newdata, time = Utime, type = "survival")
> 
> ## display
> library(ggplot2)

Attaching package: ‘ggplot2’

The following object is masked from ‘package:lava’:

    vars

> autoplot(p.cox)
> autoplot(p.coxStrata)
>  
> ## compare models
> outIF <- influenceTest(list(m.cox, mStrata.cox), 
+                        type = "survival", newdata = newdata, times = Utime[1:6])
> confint(outIF)
        Comparison of two estimates of the survival at time 0.901 1.364 1.984 2.004 2.177 2.312

model 1:
coxph(formula = Surv(eventtime, status) ~ X1, data = d, x = TRUE, 
    y = TRUE)
model 2:
coxph(formula = Surv(eventtime, status) ~ strata(X1), data = d, 
    x = TRUE, y = TRUE)
    X1  time difference     se                              conf.interval
 1:  0 0.901    0.00000 0.0000                                    [0 ; 0]
 2:  0 1.364    0.01469 0.0140 [-0.0128137535186092 ; 0.0421837626207106]
 3:  0 1.984    0.00739 0.0155  [-0.0229445796653494 ; 0.037730343320489]
 4:  0 2.004    0.00739 0.0155  [-0.0229445796653494 ; 0.037730343320489]
 5:  0 2.177    0.02195 0.0200 [-0.0172488460712843 ; 0.0611415674028318]
 6:  0 2.312    0.03650 0.0232 [-0.0088844728314849 ; 0.0818841078787402]
 7:  1 0.901    0.00000 0.0000                                    [0 ; 0]
 8:  1 1.364   -0.01234 0.0120 [-0.0358307111708698 ; 0.0111453486007476]
 9:  1 1.984   -0.00627 0.0130 [-0.0317817818895643 ; 0.0192333171460028]
10:  1 2.004   -0.00627 0.0130 [-0.0317817818895643 ; 0.0192333171460028]
11:  1 2.177   -0.01871 0.0171 [-0.0521949568179435 ; 0.0147740545699256]
12:  1 2.312   -0.03108 0.0200 [-0.070209334620724 ; 0.00804722676630101]
    p.value quantileBand                                  conf.band
 1:      NA         2.34                                    [0 ; 0]
 2:   0.295         2.34 [-0.0180757420614204 ; 0.0474457511635218]
 3:   0.633         2.34 [-0.0287497645536752 ; 0.0435355282088148]
 4:   0.633         2.34 [-0.0287497645536752 ; 0.0435355282088148]
 5:   0.272         2.34 [-0.0247489931055997 ; 0.0686417144371471]
 6:   0.115         2.34 [-0.0175689237898613 ; 0.0905685588371165]
 7:      NA         2.34                                    [0 ; 0]
 8:   0.303         2.34   [-0.0404021458154123 ; 0.01571678324529]
 9:   0.630         2.34 [-0.0367462721482143 ; 0.0241978074046528]
10:   0.630         2.34 [-0.0367462721482143 ; 0.0241978074046528]
11:   0.273         2.34 [-0.0587119882645492 ; 0.0212910860165314]
12:   0.120         2.34 [-0.0778248042370913 ; 0.0156626963826684]
> 
> #### Under H0 (CSC) ####
> set.seed(1)
> ff <- ~ f(X1,2) + f(X2,-0.033)
> ff <- update(ff, ~ .+ f(X3,0) + f(X4,0) + f(X5,0))
> ff <- update(ff, ~ .+ f(X6,0) + f(X7,0) + f(X8,0) + f(X9,0))
> d <- sampleData(n, outcome = "competing.risk", formula = ff)
> d[,X1:=as.numeric(as.character(X1))]
> d[,X2:=as.numeric(as.character(X2))]
> d[,X3:=as.numeric(as.character(X3))]
> d[,X4:=as.numeric(as.character(X4))]
> d[,X5:=as.numeric(as.character(X5))]
> setkey(d, time)
> 
> Utime <- sort(unique(d$time))
> 
> ## fit cox models
> m.CSC <- CSC(Hist(time, event) ~ X1 + X2, data = d)
> mStrata.CSC <- CSC(Hist(time, event) ~ strata(X1) + X2 + X3, data = d)
> 
> ## compare models
> outIF <- influenceTest(list(m.CSC, mStrata.CSC), 
+              cause = 1, newdata = unique(d[,.(X1,X2,X3)]), times = Utime[1:5])
> confint(outIF)
        Comparison of two estimates of the absRisk at time 0.391 0.726 0.857 0.901 0.905

model 1:
CSC(formula = Hist(time, event) ~ X1 + X2, data = d)
model 2:
CSC(formula = Hist(time, event) ~ strata(X1) + X2 + X3, data = d)
    X1 X2  time difference      se                               conf.interval
 1:  0  0 0.391  -0.007397 0.00744   [-0.0219743786938676 ; 0.007181371548271]
 2:  0  0 0.726  -0.002655 0.00817  [-0.0186698939924953 ; 0.0133604070247085]
 3:  0  0 0.857  -0.002655 0.00817  [-0.0186698939924953 ; 0.0133604070247085]
 4:  0  0 0.901  -0.002655 0.00817  [-0.0186698939924953 ; 0.0133604070247085]
 5:  0  0 0.905  -0.002655 0.00817  [-0.0186698939924953 ; 0.0133604070247085]
 6:  1  0 0.391   0.050593 0.04990   [-0.0472082077990555 ; 0.148394996371111]
 7:  1  0 0.726   0.006225 0.06230    [-0.115873609888316 ; 0.128323390542715]
 8:  1  0 0.857   0.006225 0.06230    [-0.115873609888316 ; 0.128323390542715]
 9:  1  0 0.901   0.006225 0.06230    [-0.115873609888316 ; 0.128323390542715]
10:  1  0 0.905   0.006225 0.06230    [-0.115873609888316 ; 0.128323390542715]
11:  0  0 0.391  -0.005261 0.00553 [-0.0161037293343764 ; 0.00558179576256139]
12:  0  0 0.726  -0.000519 0.00702   [-0.0142878452210002 ; 0.013249431826995]
13:  0  0 0.857  -0.000519 0.00702   [-0.0142878452210002 ; 0.013249431826995]
14:  0  0 0.901  -0.000519 0.00702   [-0.0142878452210002 ; 0.013249431826995]
15:  0  0 0.905  -0.000519 0.00702   [-0.0142878452210002 ; 0.013249431826995]
16:  0  1 0.391  -0.007153 0.00745 [-0.0217639911955695 ; 0.00745730249264883]
17:  0  1 0.726  -0.002897 0.00794   [-0.018450160664212 ; 0.0126555179617021]
18:  0  1 0.857  -0.002897 0.00794   [-0.018450160664212 ; 0.0126555179617021]
19:  0  1 0.901  -0.002897 0.00794   [-0.018450160664212 ; 0.0126555179617021]
20:  0  1 0.905  -0.002897 0.00794   [-0.018450160664212 ; 0.0126555179617021]
21:  1  1 0.391   0.045388 0.04538   [-0.0435460500690034 ; 0.134322958157996]
22:  1  1 0.726   0.017186 0.04965   [-0.0801261495409474 ; 0.114498317293765]
23:  1  1 0.857   0.017186 0.04965   [-0.0801261495409474 ; 0.114498317293765]
24:  1  1 0.901   0.017186 0.04965   [-0.0801261495409474 ; 0.114498317293765]
25:  1  1 0.905   0.017186 0.04965   [-0.0801261495409474 ; 0.114498317293765]
26:  0  1 0.391  -0.005146 0.00535 [-0.0156264718939994 ; 0.00533364739249466]
27:  0  1 0.726  -0.000890 0.00664    [-0.013894957572693 ; 0.012114179071599]
28:  0  1 0.857  -0.000890 0.00664    [-0.013894957572693 ; 0.012114179071599]
29:  0  1 0.901  -0.000890 0.00664    [-0.013894957572693 ; 0.012114179071599]
30:  0  1 0.905  -0.000890 0.00664    [-0.013894957572693 ; 0.012114179071599]
31:  1  0 0.391   0.050593 0.04990   [-0.0472082077990555 ; 0.148394996371111]
32:  1  0 0.726   0.022522 0.05427   [-0.0838491483671032 ; 0.128892887023336]
33:  1  0 0.857   0.022522 0.05427   [-0.0838491483671032 ; 0.128892887023336]
34:  1  0 0.901   0.022522 0.05427   [-0.0838491483671032 ; 0.128892887023336]
35:  1  0 0.905   0.022522 0.05427   [-0.0838491483671032 ; 0.128892887023336]
    X1 X2  time difference      se                               conf.interval
    p.value quantileBand                                   conf.band
 1:   0.320         2.14  [-0.0233028706160571 ; 0.0085098634704605]
 2:   0.745         2.14  [-0.0201293658226921 ; 0.0148198788549053]
 3:   0.745         2.14  [-0.0201293658226921 ; 0.0148198788549053]
 4:   0.745         2.14  [-0.0201293658226921 ; 0.0148198788549053]
 5:   0.745         2.14  [-0.0201293658226921 ; 0.0148198788549053]
 6:   0.311         2.20   [-0.0589422488110803 ; 0.160129037383135]
 7:   0.920         2.20    [-0.130522744242876 ; 0.142972524897274]
 8:   0.920         2.20    [-0.130522744242876 ; 0.142972524897274]
 9:   0.920         2.20    [-0.130522744242876 ; 0.142972524897274]
10:   0.920         2.20    [-0.130522744242876 ; 0.142972524897274]
11:   0.342         2.15 [-0.0171743014576497 ; 0.00665236788583472]
12:   0.941         2.15  [-0.0156473069368985 ; 0.0146088935428933]
13:   0.941         2.15  [-0.0156473069368985 ; 0.0146088935428933]
14:   0.941         2.15  [-0.0156473069368985 ; 0.0146088935428933]
15:   0.941         2.15  [-0.0156473069368985 ; 0.0146088935428933]
16:   0.337         2.14  [-0.023111000275824 ; 0.00880431157290333]
17:   0.715         2.14   [-0.019884033921284 ; 0.0140893912187741]
18:   0.715         2.14   [-0.019884033921284 ; 0.0140893912187741]
19:   0.715         2.14   [-0.019884033921284 ; 0.0140893912187741]
20:   0.715         2.14   [-0.019884033921284 ; 0.0140893912187741]
21:   0.317         2.14   [-0.0516932460308556 ; 0.142470154119848]
22:   0.729         2.14   [-0.0890408204331906 ; 0.123412988186009]
23:   0.729         2.14   [-0.0890408204331906 ; 0.123412988186009]
24:   0.729         2.14   [-0.0890408204331906 ; 0.123412988186009]
25:   0.729         2.14   [-0.0890408204331906 ; 0.123412988186009]
26:   0.336         2.15 [-0.0166329701571154 ; 0.00634014565561073]
27:   0.893         2.15  [-0.0151439080438144 ; 0.0133631295427205]
28:   0.893         2.15  [-0.0151439080438144 ; 0.0133631295427205]
29:   0.893         2.15  [-0.0151439080438144 ; 0.0133631295427205]
30:   0.893         2.15  [-0.0151439080438144 ; 0.0133631295427205]
31:   0.311         2.14   [-0.0563341481430406 ; 0.157520936715096]
32:   0.678         2.14    [-0.0937747072651166 ; 0.13881844592135]
33:   0.678         2.14    [-0.0937747072651166 ; 0.13881844592135]
34:   0.678         2.14    [-0.0937747072651166 ; 0.13881844592135]
35:   0.678         2.14    [-0.0937747072651166 ; 0.13881844592135]
    p.value quantileBand                                   conf.band
> 
> 
> 
> cleanEx()

detaching ‘package:ggplot2’, ‘package:data.table’, ‘package:prodlim’,
  ‘package:survival’, ‘package:lava’

> nameEx("ipcw")
> ### * ipcw
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ipcw
> ### Title: Estimation of censoring probabilities
> ### Aliases: ipcw ipcw.none ipcw.marginal ipcw.nonpar ipcw.cox ipcw.aalen
> ### Keywords: survival
> 
> ### ** Examples
> 
> 
> library(prodlim)
> library(rms)
Loading required package: Hmisc
Loading required package: lattice
Loading required package: survival
Loading required package: Formula
Loading required package: ggplot2

Attaching package: ‘Hmisc’

The following objects are masked from ‘package:base’:

    format.pval, units

Loading required package: SparseM

Attaching package: ‘SparseM’

The following object is masked from ‘package:base’:

    backsolve

> dat=SimSurv(30)
> 
> dat <- dat[order(dat$time),]
> 
> # using the marginal Kaplan-Meier for the censoring times
> 
> WKM=ipcw(Hist(time,status)~X2,
+   data=dat,
+   method="marginal",
+   times=sort(unique(dat$time)),
+   subject.times=dat$time,keep=c("fit"))
> plot(WKM$fit)
> WKM$fit

Call: prodlim::prodlim(formula = formula, data = data, reverse = TRUE)

Kaplan-Meier estimator for the censoring time survival function

No covariates

Right-censored response of a survival model

No.Observations: 30 

Pattern:
                Freq
 event          19  
 right.censored 11  
> 
> # using the Cox model for the censoring times given X2
> library(survival)
> WCox=ipcw(Hist(time=time,event=status)~X2,
+   data=dat,
+   method="cox",
+   times=sort(unique(dat$time)),
+   subject.times=dat$time,keep=c("fit"))
> WCox$fit
Cox Proportional Hazards Model
 
 (function (formula = formula(data), data = parent.frame(), weights, 
     subset, na.action = na.delete, method = c("efron", "breslow", 
         "exact", "model.frame", "model.matrix"), singular.ok = FALSE, 
     robust = FALSE, model = FALSE, x = FALSE, y = FALSE, se.fit = FALSE, 
     linear.predictors = TRUE, residuals = TRUE, nonames = FALSE, 
     eps = 1e-04, init, iter.max = 10, tol = 1e-09, surv = FALSE, 
     time.inc, type = NULL, vartype = NULL, debug = FALSE, ...) 
 {
     method <- match.arg(method)
     call <- match.call()
     m <- match.call(expand.dots = FALSE)
     mc <- match(c("formula", "data", "subset", "weights", "na.action"), 
         names(m), 0)
     m <- m[c(1, mc)]
     m$na.action <- na.action
     m$drop.unused.levels <- TRUE
     m[[1]] <- as.name("model.frame")
     if (!inherits(formula, "formula")) {
         if (inherits(formula, "Surv")) {
             xx <- function(x) formula(x)
             formula <- xx(paste(deparse(substitute(formula)), 
                 1, sep = "~"))
         }
         else stop("Invalid formula")
     }
     m$formula <- formula
     nstrata <- 0
     Strata <- NULL
     odb <- .Options$debug
     if (length(odb) && is.logical(odb) && odb) 
         debug <- TRUE
     if (!missing(data) || (length(z <- attr(terms(formula, allowDotAsName = TRUE), 
         "term.labels")) > 0 && any(z != "."))) {
         dul <- .Options$drop.unused.levels
         if (!length(dul) || dul) {
             on.exit(options(drop.unused.levels = dul))
             options(drop.unused.levels = FALSE)
         }
         X <- Design(eval.parent(m))
         atrx <- attributes(X)
         atr <- atrx$Design
         nact <- atrx$na.action
         sformula <- atrx$sformula
         mmcolnames <- atr$mmcolnames
         if (method == "model.frame") 
             return(X)
         Terms <- if (missing(data)) 
             terms(sformula, specials = c("strat", "strata"))
         else terms(sformula, specials = c("strat", "strata"), 
             data = data)
         asm <- atr$assume.code
         name <- atr$name
         specials <- attr(Terms, "specials")
         if (length(specials$strata)) 
             stop("cph supports strat(), not strata()")
         stra <- specials$strat
         cluster <- attr(X, "cluster")
         if (length(cluster)) {
             if (missing(robust)) 
                 robust <- TRUE
             attr(X, "cluster") <- NULL
         }
         Terms.ns <- Terms
         if (length(stra)) {
             temp <- untangle.specials(Terms.ns, "strat", 1)
             Terms.ns <- Terms.ns[-temp$terms]
             Strata <- list()
             strataname <- attr(Terms, "term.labels")[stra - 1]
             j <- 0
             for (i in (1:length(asm))[asm == 8]) {
                 nstrata <- nstrata + 1
                 xi <- X[[i + 1]]
                 levels(xi) <- paste(name[i], "=", levels(xi), 
                   sep = "")
                 Strata[[nstrata]] <- xi
             }
             Strata <- interaction(as.data.frame(Strata), drop = TRUE)
         }
         xpres <- length(asm) && any(asm != 8)
         Y <- model.extract(X, "response")
         if (!inherits(Y, "Surv")) 
             stop("response variable should be a Surv object")
         n <- nrow(Y)
         weights <- model.extract(X, "weights")
         offset <- attr(X, "offset")
         if (!xpres) {
             X <- matrix(nrow = 0, ncol = 0)
             assign <- NULL
         }
         else {
             X <- model.matrix(sformula, X)
             alt <- attr(mmcolnames, "alt")
             if (debug) {
                 prn(sformula)
                 print(cbind(`colnames(X)` = colnames(X)[-1], 
                   mmcolnames = mmcolnames, `Design colnames` = atr$colnames, 
                   alt = alt))
             }
             if (!all(mmcolnames %in% colnames(X)) && length(alt)) 
                 mmcolnames <- alt
             X <- X[, mmcolnames, drop = FALSE]
             assign <- attr(X, "assign")
             assign[[1]] <- NULL
         }
         nullmod <- FALSE
     }
     else {
         X <- NULL
         Terms <- terms(formula)
         yy <- attr(terms(formula), "variables")[1]
         Y <- eval(yy, data)
         if (!inherits(Y, "Surv")) 
             stop("response variable should be a Surv object")
         Y <- Y[!is.na(Y)]
         assign <- NULL
         xpres <- FALSE
         nullmod <- TRUE
         nact <- NULL
     }
     ny <- ncol(Y)
     maxtime <- max(Y[, ny - 1])
     rnam <- if (!nonames) 
         dimnames(Y)[[1]]
     if (xpres) 
         dimnames(X) <- list(rnam, atr$colnames)
     if (method == "model.matrix") 
         return(X)
     time.units <- units(Y)
     if (!length(time.units) || time.units == "") 
         time.units <- "Day"
     if (missing(time.inc)) {
         time.inc <- switch(time.units, Day = 30, Month = 1, Year = 1, 
             maxtime/10)
         if (time.inc >= maxtime | maxtime/time.inc > 25) 
             time.inc <- max(pretty(c(0, maxtime)))/10
     }
     ytype <- attr(Y, "type")
     if (nullmod) 
         f <- NULL
     else {
         fitter <- if (method == "breslow" || method == "efron") {
             if (ytype == "right") 
                 coxph.fit
             else agreg.fit
         }
         else if (method == "exact") {
             if (ytype == "right") 
                 getFromNamespace("coxexact.fit", "survival")
             else agexact.fit
         }
         else stop(paste("Unknown method", method))
         if (missing(init)) 
             init <- NULL
         f <- fitter(X, Y, strata = Strata, offset = offset, weights = weights, 
             init = init, method = method, rownames = rnam, control = coxph.control(eps = eps, 
                 toler.chol = tol, toler.inf = 1, iter.max = iter.max))
     }
     if (is.character(f)) {
         cat("Failure in cph:\n", f, "\n")
         return(structure(list(fail = TRUE), class = "cph"))
     }
     else {
         if (length(f$coefficients) && any(is.na(f$coefficients))) {
             vars <- names(f$coefficients)[is.na(f$coefficients)]
             msg <- paste("X matrix deemed to be singular; variable", 
                 paste(vars, collapse = " "))
             if (singular.ok) 
                 warning(msg)
             else {
                 cat(msg, "\n")
                 return(structure(list(fail = TRUE), class = "cph"))
             }
         }
     }
     f$terms <- Terms
     f$sformula <- sformula
     f$mmcolnames <- mmcolnames
     if (robust) {
         f$naive.var <- f$var
         if (!length(cluster)) 
             cluster <- FALSE
         fit2 <- c(f, list(x = X, y = Y, weights = weights, method = method))
         if (length(stra)) 
             fit2$strata <- Strata
         r <- getS3method("residuals", "coxph")(fit2, type = "dfbeta", 
             collapse = cluster, weighted = TRUE)
         f$var <- t(r) %*% r
     }
     nvar <- length(f$coefficients)
     ev <- factor(Y[, ny], levels = 0:1, labels = c("No Event", 
         "Event"))
     n.table <- {
         if (!length(Strata)) 
             table(ev, dnn = "Status")
         else table(Strata, ev, dnn = c("Stratum", "Status"))
     }
     f$n <- n.table
     nevent <- sum(Y[, ny])
     if (xpres) {
         logtest <- -2 * (f$loglik[1] - f$loglik[2])
         R2.max <- 1 - exp(2 * f$loglik[1]/n)
         R2 <- (1 - exp(-logtest/n))/R2.max
         P <- 1 - pchisq(logtest, nvar)
         gindex <- GiniMd(f$linear.predictors)
         dxy <- dxy.cens(f$linear.predictors, Y, type = "hazard")["Dxy"]
         stats <- c(n, nevent, logtest, nvar, P, f$score, 1 - 
             pchisq(f$score, nvar), R2, dxy, gindex, exp(gindex))
         names(stats) <- c("Obs", "Events", "Model L.R.", "d.f.", 
             "P", "Score", "Score P", "R2", "Dxy", "g", "gr")
     }
     else {
         stats <- c(n, nevent)
         names(stats) <- c("Obs", "Events")
     }
     f$method <- NULL
     if (xpres) 
         dimnames(f$var) <- list(atr$colnames, atr$colnames)
     f <- c(f, list(call = call, Design = atr, assign = DesignAssign(atr, 
         0, atrx$terms), na.action = nact, fail = FALSE, non.slopes = 0, 
         stats = stats, method = method, maxtime = maxtime, time.inc = time.inc, 
         units = time.units))
     if (xpres) {
         f$center <- sum(f$means * f$coefficients)
         f$scale.pred <- c("log Relative Hazard", "Hazard Ratio")
         attr(f$linear.predictors, "strata") <- Strata
         names(f$linear.predictors) <- rnam
         if (se.fit) {
             XX <- X - rep(f$means, rep.int(n, nvar))
             se.fit <- drop(((XX %*% f$var) * XX) %*% rep(1, ncol(XX)))^0.5
             names(se.fit) <- rnam
             f$se.fit <- se.fit
         }
     }
     if (model) 
         f$model <- m
     if (is.character(surv) || surv) {
         if (length(Strata)) {
             iStrata <- as.character(Strata)
             slev <- levels(Strata)
             nstr <- length(slev)
         }
         else nstr <- 1
         srv <- NULL
         tim <- NULL
         s.e. <- NULL
         timepts <- seq(0, maxtime, by = time.inc)
         s.sum <- array(double(1), c(length(timepts), nstr, 3), 
             list(format(timepts), paste("Stratum", 1:nstr), c("Survival", 
                 "n.risk", "std.err")))
         g <- list(n = sum(f$n), coefficients = f$coefficients, 
             linear.predictors = f$linear.predictors, method = f$method, 
             type = type, means = f$means, var = f$var, x = X, 
             y = Y, strata = Strata, offset = offset, weights = weights, 
             terms = Terms, call = call)
         g <- survfit.cph(g, se.fit = is.character(surv) || surv, 
             type = type, vartype = vartype, conf.type = "log")
         strt <- if (nstr > 1) 
             rep(names(g$strata), g$strata)
         for (k in 1:nstr) {
             j <- if (nstr == 1) 
                 TRUE
             else strt == slev[k]
             yy <- Y[if (nstr == 1) 
                 TRUE
             else iStrata == slev[k], ny - 1]
             maxt <- max(yy)
             tt <- c(0, g$time[j])
             su <- c(1, g$surv[j])
             se <- c(NA, g$std.err[j])
             if (maxt > tt[length(tt)]) {
                 tt <- c(tt, maxt)
                 su <- c(su, su[length(su)])
                 se <- c(se, NA)
             }
             kk <- 0
             for (tp in timepts) {
                 kk <- kk + 1
                 t.choice <- max((1:length(tt))[tt <= tp + 1e-06])
                 if (tp > max(tt) + 1e-06 & su[length(su)] > 0) {
                   Su <- NA
                   Se <- NA
                 }
                 else {
                   Su <- su[t.choice]
                   Se <- se[t.choice]
                 }
                 n.risk <- sum(yy >= tp)
                 s.sum[kk, k, 1:3] <- c(Su, n.risk, Se)
             }
             if (!is.character(surv)) {
                 if (nstr == 1) {
                   tim <- tt
                   srv <- su
                   s.e. <- se
                 }
                 else {
                   tim <- c(tim, list(tt))
                   srv <- c(srv, list(su))
                   s.e. <- c(s.e., list(se))
                 }
             }
         }
         if (is.character(surv)) 
             f$surv.summary <- s.sum
         else {
             if (nstr > 1) {
                 names(srv) <- names(tim) <- names(s.e.) <- levels(Strata)
             }
             f <- c(f, list(time = tim, surv = srv, std.err = s.e., 
                 surv.summary = s.sum))
         }
     }
     f$strata <- Strata
     if (x) 
         f$x <- X
     if (y) 
         f$y <- Y
     f$weights <- weights
     f$offset <- offset
     if (!linear.predictors) 
         f$linear.predictors <- NULL
     if (!residuals) 
         f$residuals <- NULL
     class(f) <- c("cph", "rms", "coxph")
     f
 })(formula = Surv(time, status) ~ X2, data = structure(list(time = c(0.492967146723343, 
 0.751028491262217, 0.85690323555647, 1.55066740292543, 1.5529911630034, 
 2.49957953925262, 2.72813843472151, 2.92453672792375, 3.09566675772413, 
 3.4939918159165, 3.63430756589682, 3.71105077263798, 4.44729303005845, 
 4.57872508730397, 4.64955854779207, 4.75934018341804, 4.99979038448156, 
 5.0854691947226, 5.25787199056587, 5.78516506840998, 6.41999506940776, 
 6.65370629975601, 7.64347118490518, 7.99067276286092, 8.98219893552586, 
 9.15741788589595, 9.16814453632736, 10.152756975698, 11.2753806784844, 
 11.4384014642223), status = c(0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 
 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1), X2 = c(0.821221195098089, 
 -0.626453810742332, -2.2146998871775, 1.12493091814311, 0.918977371608218, 
 0.61982574789471, 0.329507771815361, 0.782136300731067, 0.417941560199702, 
 1.51178116845085, 1.59528080213779, 0.593901321217509, -0.0449336090152309, 
 0.575781351653492, -0.0161902630989461, -0.820468384118015, 0.943836210685299, 
 -0.305388387156356, 0.738324705129217, -0.155795506705329, 0.487429052428485, 
 -0.835628612410047, 0.183643324222082, 0.389843236411431, -0.47815005510862, 
 -0.0561287395290008, -1.98935169586337, 0.0745649833651906, -1.47075238389927, 
 -0.621240580541804)), row.names = c("19", "1", "14", "15", "21", 
 "25", "5", "22", "30", "11", "4", "20", "16", "9", "17", "6", 
 "18", "10", "8", "27", "7", "3", "2", "12", "29", "26", "24", 
 "23", "28", "13"), class = "data.frame"), x = TRUE, y = TRUE, 
     eps = 1e-06, surv = TRUE)
 
                        Model Tests    Discrimination    
                                              Indexes    
 Obs        30    LR chi2      0.02    R2       0.001    
 Events     11    d.f.            1    Dxy      0.085    
 Center 0.0048    Pr(> chi2) 0.8864    g        0.061    
                  Score chi2   0.02    gr       1.062    
                  Pr(> chi2) 0.8869                      
 
    Coef   S.E.   Wald Z Pr(>|Z|)
 X2 0.0586 0.4118 0.14   0.8869  
 
> 
> plot(WKM$fit)
> lines(sort(unique(dat$time)),
+       1-WCox$IPCW.times[1,],
+       type="l",
+       col=2,
+       lty=3,
+       lwd=3)
> lines(sort(unique(dat$time)),
+       1-WCox$IPCW.times[5,],
+       type="l",
+       col=3,
+       lty=3,
+       lwd=3)
> 
> # using the stratified Kaplan-Meier
> # for the censoring times given X2
> 
> WKM2=ipcw(Hist(time,status)~X2,
+   data=dat,
+   method="nonpar",
+   times=sort(unique(dat$time)),
+   subject.times=dat$time,keep=c("fit"))
> plot(WKM2$fit,add=FALSE)
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:rms’, ‘package:SparseM’, ‘package:Hmisc’,
  ‘package:ggplot2’, ‘package:Formula’, ‘package:survival’,
  ‘package:lattice’, ‘package:prodlim’

> nameEx("penalizedS3")
> ### * penalizedS3
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: penalizedS3
> ### Title: S3-wrapper for S4 function penalized
> ### Aliases: penalizedS3
> 
> ### ** Examples
> 
> library(prodlim)
> ## Not run: 
> ##D ## too slow
> ##D library(penalized)
> ##D set.seed(8)
> ##D d <- sampleData(200,outcome="binary")
> ##D newd <- sampleData(80,outcome="binary")
> ##D fitridge <- penalizedS3(Y~X1+X2+pen(7:8), data=d, type="ridge",
> ##D standardize=TRUE, model="logistic",trace=FALSE)
> ##D fitlasso <- penalizedS3(Y~X1+X2+pen(7:8), data=d, type="lasso",
> ##D standardize=TRUE, model="logistic",trace=FALSE)
> ##D # fitnet <- penalizedS3(Y~X1+X2+pen(7:8), data=d, type="elastic.net",
> ##D # standardize=TRUE, model="logistic",trace=FALSE)
> ##D predictRisk(fitridge,newdata=newd)
> ##D predictRisk(fitlasso,newdata=newd)
> ##D # predictRisk(fitnet,newdata=newd)
> ##D Score(list(fitridge),data=newd,formula=Y~1)
> ##D Score(list(fitridge),data=newd,formula=Y~1,split.method="bootcv",B=2)
> ## End(Not run)
> ## Not run: 
> ##D  data(nki70) ## S4 fit
> ##D pen <- penalized(Surv(time, event), penalized = nki70[,8:77],
> ##D                  unpenalized = ~ER+Age+Diam+N+Grade, data = nki70,
> ##D lambda1 = 1)
> ##D penS3 <- penalizedS3(Surv(time,event)~ER+Age+Diam+pen(8:77)+N+Grade,
> ##D                      data=nki70, lambda1=1)
> ##D ## or
> ##D penS3 <- penalizedS3(Surv(time,event)~ER+pen(TSPYL5,Contig63649_RC)+pen(10:77)+N+Grade,
> ##D                      data=nki70, lambda1=1)
> ##D ## also this works
> ##D penS3 <- penalizedS3(Surv(time,event)~ER+Age+pen(8:33)+Diam+pen(34:77)+N+Grade,
> ##D                     data=nki70, lambda1=1)
> ## End(Not run)
> 
> 
> 
> cleanEx()

detaching ‘package:prodlim’

> nameEx("plot.riskRegression")
> ### * plot.riskRegression
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.riskRegression
> ### Title: Plotting predicted risk
> ### Aliases: plot.riskRegression
> ### Keywords: survival
> 
> ### ** Examples
> 
> 
> library(survival)
> library(prodlim)
> data(Melanoma)
> fit.arr <- ARR(Hist(time,status)~invasion+age+strata(sex),data=Melanoma,cause=1)
> plot(fit.arr,xlim=c(500,3000))
Warning in plot.riskRegression(fit.arr, xlim = c(500, 3000)) :
  Argument newdata is missing.
Shown are the cumulative incidence curves from the original data set.
Selected are curves based on individual risk (min,q25,median,q75,max) at the median time:1112.25714285714
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:prodlim’, ‘package:survival’

> nameEx("plotAUC")
> ### * plotAUC
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plotAUC
> ### Title: Plot of time-dependent AUC curves
> ### Aliases: plotAUC
> 
> ### ** Examples
> 
> library(survival)
> library(prodlim)
> d=sampleData(100,outcome="survival")
> nd=sampleData(100,outcome="survival")
> f1=coxph(Surv(time,event)~X1+X6+X8,data=d,x=TRUE,y=TRUE)
> f2=coxph(Surv(time,event)~X2+X5+X9,data=d,x=TRUE,y=TRUE)
> xx=Score(list("X1+X6+X8"=f1,"X2+X5+X9"=f2), formula=Surv(time,event)~1,
+ data=nd, metrics="auc", null.model=FALSE, times=seq(3:10))
> aucgraph <- plotAUC(xx)
> plotAUC(xx,conf.int=TRUE)
> ## difference between 
> plotAUC(xx,which="contrasts",conf.int=TRUE)
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:prodlim’, ‘package:survival’

> nameEx("plotBrier")
> ### * plotBrier
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plotBrier
> ### Title: Plot Brier curve
> ### Aliases: plotBrier
> 
> ### ** Examples
> 
> # survival
> library(survival)
> library(prodlim)
> ds1=sampleData(40,outcome="survival")
> ds2=sampleData(40,outcome="survival")
> f1 <- coxph(Surv(time,event)~X1+X3+X5+X7+X9,data=ds1,x=TRUE)
> f2 <- coxph(Surv(time,event)~X2+X4+X6+X8+X10,data=ds1,x=TRUE)
> xscore <- Score(list(f1,f2),formula=Hist(time,event)~1,data=ds2,times=0:12,metrics="brier")
> plotBrier(xscore)
> 
> 
> 
> cleanEx()

detaching ‘package:prodlim’, ‘package:survival’

> nameEx("plotCalibration")
> ### * plotCalibration
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plotCalibration
> ### Title: Plot Calibration curve
> ### Aliases: plotCalibration
> 
> ### ** Examples
> 
> library(prodlim)
> # binary 
> db=sampleData(100,outcome="binary")
> fb1=glm(Y~X1+X5+X7,data=db,family="binomial")
> fb2=glm(Y~X1+X3+X6+X7,data=db,family="binomial")
> xb=Score(list(model1=fb1,model2=fb2),Y~1,data=db,
+           plots="cal")
> plotCalibration(xb,brier.in.legend=TRUE)
> plotCalibration(xb,bars=TRUE,model="model1")
> plotCalibration(xb,models=1,bars=TRUE,names.cex=1.3)
> 
> # survival
> library(survival)
> library(prodlim)
> dslearn=sampleData(56,outcome="survival")
> dstest=sampleData(100,outcome="survival")
> fs1=coxph(Surv(time,event)~X1+X5+X7,data=dslearn,x=1)
> fs2=coxph(Surv(time,event)~strata(X1)+X3+X6+X7,data=dslearn,x=1)
> xs=Score(list(Cox1=fs1,Cox2=fs2),Surv(time,event)~1,data=dstest,
+           plots="cal",metrics=NULL)
> plotCalibration(xs)
The default method for estimating calibration curves based on censored data has changed for riskRegression version 2019-9-8 or higher
Set cens.method="jackknife" to get the estimate using pseudo-values.
However, note that the option "jackknife" is sensititve to violations of the assumption that the censoring is independent of both the event times and the covariates.
Set cens.method="local" to suppress this message.
> plotCalibration(xs,cens.method="local",pseudo=1)
> plotCalibration(xs,method="quantile")
The default method for estimating calibration curves based on censored data has changed for riskRegression version 2019-9-8 or higher
Set cens.method="jackknife" to get the estimate using pseudo-values.
However, note that the option "jackknife" is sensititve to violations of the assumption that the censoring is independent of both the event times and the covariates.
Set cens.method="local" to suppress this message.
> 
> 
> # competing risks
> 
> ## Not run: 
> ##D data(Melanoma)
> ##D f1 <- CSC(Hist(time,status)~age+sex+epicel+ulcer,data=Melanoma)
> ##D f2 <- CSC(Hist(time,status)~age+sex+logthick+epicel+ulcer,data=Melanoma)
> ##D x <- Score(list(model1=f1,model2=f2),Hist(time,status)~1,data=Melanoma,
> ##D            cause= 2,times=5*365.25,plots="cal")
> ##D plotCalibration(x)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()

detaching ‘package:survival’, ‘package:prodlim’

> nameEx("plotEffects")
> ### * plotEffects
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plotEffects
> ### Title: Plotting time-varying effects from a risk regression model.
> ### Aliases: plotEffects
> ### Keywords: survival
> 
> ### ** Examples
> 
> 
> library(survival)
> library(prodlim)
> data(Melanoma)
> 
> fit.tarr <- ARR(Hist(time,status)~strata(sex),
+                 data=Melanoma,
+                 cause=1)
> plotEffects(fit.tarr)
> 
> fit.tarr <- ARR(Hist(time,status)~strata(sex)+strata(invasion),
+                 data=Melanoma,
+                 cause=1,
+                 times=seq(800,3000,20))
> plotEffects(fit.tarr,formula=~sex)
> plotEffects(fit.tarr,formula=~invasion)
> plotEffects(fit.tarr,
+             formula=~invasion,
+             level="invasionlevel.1")
> 
> ## legend arguments are transcluded:
> plotEffects(fit.tarr,
+             formula=~invasion,
+             legend.bty="b",
+             legend.cex=1)
> 
> ## and other smart arguments too:
> plotEffects(fit.tarr,
+ 	    formula=~invasion,
+ 	    legend.bty="b",
+ axis2.las=2,
+ 	    legend.cex=1)
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:prodlim’, ‘package:survival’

> nameEx("plotPredictRisk")
> ### * plotPredictRisk
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plotPredictRisk
> ### Title: Plotting predicted risks curves.
> ### Aliases: plotPredictRisk
> ### Keywords: survival
> 
> ### ** Examples
> 
> library(survival)
> # generate survival data
> # no effect
> set.seed(8)
> d <- sampleData(80,outcome="survival",formula = ~f(X6, 0) + f(X7, 0))
> d[,table(event)]
event
 0  1 
40 40 
> f <- coxph(Surv(time,event)~X6+X7,data=d,x=1)
> plotPredictRisk(f)
> 
> # large effect
> set.seed(8)
> d <- sampleData(80,outcome="survival",formula = ~f(X6, 0.1) + f(X7, -0.1))
> d[,table(event)]
event
 0  1 
41 39 
> f <- coxph(Surv(time,event)~X6+X7,data=d,x=1)
> plotPredictRisk(f)
> 
> # generate competing risk data
> # small effect
> set.seed(8)
> d <- sampleData(40,formula = ~f(X6, 0.01) + f(X7, -0.01))
> d[,table(event)]
event
 0  1  2 
11 16 13 
> f <- CSC(Hist(time,event)~X5+X6,data=d)
> plotPredictRisk(f)
> 
> # large effect
> set.seed(8)
> d <- sampleData(40,formula = ~f(X6, 0.1) + f(X7, -0.1))
> d[,table(event)]
event
 0  1  2 
 7 21 12 
> f <- CSC(Hist(time,event)~X5+X6,data=d)
> plotPredictRisk(f)
> 
> 
> 
> cleanEx()

detaching ‘package:survival’

> nameEx("plotROC")
> ### * plotROC
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plotROC
> ### Title: Plot ROC curves
> ### Aliases: plotROC
> 
> ### ** Examples
> 
> ## binary
> set.seed(18)
> library(randomForest)
randomForest 4.6-14
Type rfNews() to see new features/changes/bug fixes.
> library(prodlim)
> bdl <- sampleData(40,outcome="binary")
> bdt <- sampleData(58,outcome="binary")
> bdl[,y:=factor(Y)]
> bdt[,y:=factor(Y)]
> fb1 <- glm(y~X1+X2+X3+X4+X5+X6+X7+X8+X9+X10,data=bdl,family="binomial")
> fb2 <- randomForest(y~X1+X2+X3+X4+X5+X6+X7+X8+X9+X10,data=bdl)
> xb <- Score(list("glm"=fb1,"rf"=fb2),y~1,data=bdt,
+             plots="roc",metrics=c("auc","brier"))
> plotROC(xb,brier.in.legend=1L)
> 
> # with cross-validation
> ## Not run: 
> ##D xb3 <- Score(list("glm"=fb1,"rf"=fb2),y~1,data=bdl,
> ##D             plots="roc",B=3,split.method="bootcv",
> ##D             metrics=c("auc"))
> ## End(Not run)
> ## survival
> set.seed(18)
> library(survival)
> sdl <- sampleData(40,outcome="survival")
> sdt <- sampleData(58,outcome="survival")
> fs1 <- coxph(Surv(time,event)~X3+X5+X6+X7+X8+X10,data=sdl,x=TRUE)
> fs2 <- coxph(Surv(time,event)~X1+X2+X9,data=sdl,x=TRUE)
> xs <- Score(list(model1=fs1,model2=fs2),Hist(time,event)~1,data=sdt,
+             times=5,plots="roc",metrics="auc")
> plotROC(xs)
> ## competing risks
> data(Melanoma)
> f1 <- CSC(Hist(time,status)~age+sex+epicel+ulcer,data=Melanoma)
> f2 <- CSC(Hist(time,status)~age+sex+logthick+epicel+ulcer,data=Melanoma)
> x <- Score(list(model1=f1,model2=f2),Hist(time,status)~1,data=Melanoma,
+             cause=1,times=5*365.25,plots="roc",metrics="auc")
> plotROC(x)
> 
> 
> 
> cleanEx()

detaching ‘package:survival’, ‘package:prodlim’, ‘package:randomForest’

> nameEx("plotRisk")
> ### * plotRisk
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plotRisk
> ### Title: plot predicted risks
> ### Aliases: plotRisk
> 
> ### ** Examples
> 
> library(prodlim)
> ## uncensored
> learndat = sampleData(40,outcome="binary")
> testdat = sampleData(40,outcome="binary")
> lr1 = glm(Y~X1+X2+X7+X9,data=learndat,family="binomial")
> lr2 = glm(Y~X3+X5+X6,data=learndat,family="binomial")
> xb=Score(list("LR(X1+X2+X7+X9)"=lr1,"LR(X3+X5+X6)"=lr2),formula=Y~1,
+          data=testdat,summary="risks",null.model=0L)
> plotRisk(xb)
> ## survival
> library(survival)
> learndat = sampleData(40,outcome="survival")
> testdat = sampleData(40,outcome="survival")
> cox1 = coxph(Surv(time,event)~X1+X2+X7+X9,data=learndat,x=TRUE)
> cox2 = coxph(Surv(time,event)~X3+X5+X6,data=learndat,x=TRUE)
> xs=Score(list("Cox(X1+X2+X7+X9)"=cox1,"Cox(X3+X5+X6)"=cox2),formula=Surv(time,event)~1,
+          data=testdat,summary="risks",null.model=0L,times=c(3,5,6))
> plotRisk(xs,times=5)
> ## competing risk
> ## Not run: 
> ##D library(prodlim)
> ##D library(survival)
> ##D set.seed(8)
> ##D learndat = sampleData(80,outcome="competing.risk")
> ##D testdat = sampleData(140,outcome="competing.risk")
> ##D m1 = FGR(Hist(time,event)~X2+X7+X9,data=learndat,cause=1)
> ##D m2 = CSC(Hist(time,event)~X2+X7+X9,data=learndat,cause=1)
> ##D xcr=Score(list("FGR"=m1,"CSC"=m2),formula=Hist(time,event)~1,
> ##D          data=testdat,summary="risks",null.model=0L,times=c(3,5))
> ##D plotRisk(xcr,times=1)
> ## End(Not run)
> 
> 
> 
> cleanEx()

detaching ‘package:survival’, ‘package:prodlim’

> nameEx("predict.CauseSpecificCox")
> ### * predict.CauseSpecificCox
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: predict.CauseSpecificCox
> ### Title: Predicting Absolute Risk from Cause-Specific Cox Models
> ### Aliases: predict.CauseSpecificCox predictBig.CauseSpecificCox
> 
> ### ** Examples
> 
> library(survival)
> library(prodlim)
> #### generate data ####
> set.seed(5)
> d <- sampleData(80,outcome="comp") ## training dataset
> nd <- sampleData(4,outcome="comp") ## validation dataset
> d$time <- round(d$time,1) ## create tied events
> ttt <- sort(sample(x = unique(d$time), size = 10))
> 
> ## estimate a CSC model based on the coxph function
> CSC.fit <- CSC(Hist(time,event)~ X3+X8, data=d, method = "breslow")
> 
> ## compute the absolute risk of cause 1, in the validation dataset
> ## at time 1:10
> CSC.risk <-  predict(CSC.fit, newdata=nd, times=1:10, cause=1)
> CSC.risk
    observation X3      X8 times absRisk
 1:           1  1 -1.5612     1  0.0969
 2:           2  1 -0.7577     1  0.0948
 3:           3  0  1.5421     1  0.0810
 4:           4  0 -0.0647     1  0.0847
 5:           1  1 -1.5612     2  0.2667
 6:           2  1 -0.7577     2  0.2617
 7:           3  0  1.5421     2  0.2270
 8:           4  0 -0.0647     2  0.2359
 9:           1  1 -1.5612     3  0.3574
10:           2  1 -0.7577     3  0.3520
11:           3  0  1.5421     3  0.3085
12:           4  0 -0.0647     3  0.3186
13:           1  1 -1.5612     4  0.4220
14:           2  1 -0.7577     4  0.4172
15:           3  0  1.5421     4  0.3689
16:           4  0 -0.0647     4  0.3784
17:           1  1 -1.5612     5  0.4572
18:           2  1 -0.7577     5  0.4535
19:           3  0  1.5421     5  0.4036
20:           4  0 -0.0647     5  0.4113
21:           1  1 -1.5612     6  0.4765
22:           2  1 -0.7577     6  0.4738
23:           3  0  1.5421     6  0.4235
24:           4  0 -0.0647     6  0.4295
25:           1  1 -1.5612     7  0.5401
26:           2  1 -0.7577     7  0.5428
27:           3  0  1.5421     7  0.4934
28:           4  0 -0.0647     7  0.4903
29:           1  1 -1.5612     8  0.5625
30:           2  1 -0.7577     8  0.5671
31:           3  0  1.5421     8  0.5185
32:           4  0 -0.0647     8  0.5120
33:           1  1 -1.5612     9  0.5625
34:           2  1 -0.7577     9  0.5671
35:           3  0  1.5421     9  0.5185
36:           4  0 -0.0647     9  0.5120
37:           1  1 -1.5612    10  0.5967
38:           2  1 -0.7577    10  0.6073
39:           3  0  1.5421    10  0.5629
40:           4  0 -0.0647    10  0.5456
    observation X3      X8 times absRisk
> 
> ## compute absolute risks with CI for cause 2
> ## (without displaying the value of the covariates)
> predict(CSC.fit,newdata=nd,times=1:10,cause=2,se=TRUE,
+         keep.newdata = FALSE)
    observation times absRisk absRisk.se absRisk.lower absRisk.upper
 1:           1     1 0.00000     0.0000      0.000000        0.0000
 2:           2     1 0.00000     0.0000      0.000000        0.0000
 3:           3     1 0.00000     0.0000      0.000000        0.0000
 4:           4     1 0.00000     0.0000      0.000000        0.0000
 5:           1     2 0.01409     0.0155      0.000855        0.0764
 6:           2     2 0.01107     0.0113      0.000904        0.0554
 7:           3     2 0.00907     0.0111      0.000397        0.0593
 8:           4     2 0.01470     0.0153      0.001073        0.0739
 9:           1     3 0.06024     0.0455      0.008579        0.1904
10:           2     3 0.04785     0.0258      0.013482        0.1170
11:           3     3 0.04038     0.0297      0.006543        0.1290
12:           4     3 0.06422     0.0379      0.015235        0.1651
13:           1     4 0.06024     0.0455      0.008579        0.1904
14:           2     4 0.04785     0.0258      0.013482        0.1170
15:           3     4 0.04038     0.0297      0.006543        0.1290
16:           4     4 0.06422     0.0379      0.015235        0.1651
17:           1     5 0.14687     0.0920      0.026324        0.3636
18:           2     5 0.11898     0.0639      0.030524        0.2729
19:           3     5 0.10403     0.0816      0.011531        0.3174
20:           4     5 0.15961     0.0563      0.068873        0.2841
21:           1     6 0.18485     0.1198      0.027826        0.4513
22:           2     6 0.15128     0.0838      0.034903        0.3454
23:           3     6 0.13399     0.0953      0.017909        0.3663
24:           4     6 0.20173     0.0599      0.100005        0.3286
25:           1     7 0.18485     0.1198      0.027826        0.4513
26:           2     7 0.15128     0.0838      0.034903        0.3454
27:           3     7 0.13399     0.0953      0.017909        0.3663
28:           4     7 0.20173     0.0599      0.100005        0.3286
29:           1     8 0.20546     0.1285      0.032271        0.4822
30:           2     8 0.16927     0.0915      0.039727        0.3760
31:           3     8 0.15172     0.1087      0.018870        0.4083
32:           4     8 0.22556     0.0641      0.114794        0.3590
33:           1     9 0.25516     0.1524      0.040038        0.5600
34:           2     9 0.21404     0.1110      0.050731        0.4506
35:           3     9 0.19687     0.1332      0.025363        0.4873
36:           4     9 0.28284     0.0732      0.151571        0.4294
37:           1    10 0.25516     0.1524      0.040038        0.5600
38:           2    10 0.21404     0.1110      0.050731        0.4506
39:           3    10 0.19687     0.1332      0.025363        0.4873
40:           4    10 0.28284     0.0732      0.151571        0.4294
    observation times absRisk absRisk.se absRisk.lower absRisk.upper
> 
> ## other example
> library(survival)
> CSC.fit.s <- CSC(list(Hist(time,event)~ strata(X1)+X2+X9,
+  Hist(time,event)~ X2+strata(X4)+X8+X7),data=d, method = "breslow")
> predict(CSC.fit.s,cause=1,times=ttt,se=1L) ## note: absRisk>1 due to small number of observations
     observation X2     X9       X8   X7 times    strata absRisk absRisk.se
  1:           1  0 -0.836 -0.39410 57.5   0.6 X1=0 X4=1  0.0871     0.0417
  2:           2  0  2.030 -1.51024 56.2   0.6 X1=0 X4=0  0.0170     0.0102
  3:           3  0  0.429  0.00599 77.0   0.6 X1=0 X4=1  0.0426     0.0202
  4:           4  0  1.064  0.85501 57.7   0.6 X1=0 X4=1  0.0297     0.0151
  5:           5  1 -0.606  0.72985 68.6   0.6 X1=0 X4=0  0.1319     0.0577
 ---                                                                       
796:          76  0  0.477  0.36861 63.9  11.8 X1=0 X4=0  0.4500     0.0877
797:          77  0  1.308  0.64851 58.3  11.8 X1=0 X4=0  0.3206     0.0853
798:          78  0  1.806 -0.43983 59.9  11.8 X1=0 X4=0  0.2397     0.0794
799:          79  1  1.035 -0.86642 59.3  11.8 X1=0 X4=0  0.4509     0.1609
800:          80  0  0.517  0.86530 59.7  11.8 X1=1 X4=0      NA         NA
     absRisk.lower absRisk.upper
  1:       0.02773        0.1899
  2:       0.00441        0.0470
  3:       0.01445        0.0954
  4:       0.00939        0.0706
  5:       0.04538        0.2654
 ---                            
796:       0.27569        0.6096
797:       0.16536        0.4872
798:       0.10535        0.4039
799:       0.14713        0.7182
800:            NA            NA
> 
> ## using the cph function instead of coxph
> CSC.cph <- CSC(Hist(time,event)~ X1+X2,data=d, method = "breslow", fitter = "cph")#' 
> predict(CSC.cph, newdata = d, cause = 2, times = ttt)
     observation X1 X2 times absRisk
  1:           1  0  0   0.6   0.000
  2:           2  0  0   0.6   0.000
  3:           3  0  0   0.6   0.000
  4:           4  0  0   0.6   0.000
  5:           5  0  1   0.6   0.000
 ---                                
796:          76  0  0  11.8   0.499
797:          77  0  0  11.8   0.499
798:          78  0  0  11.8   0.499
799:          79  0  1  11.8   0.340
800:          80  1  0  11.8   0.242
> 
> ## landmark analysis
> T0 <- 1
> predCSC_afterT0 <- predict(CSC.fit, newdata = d, cause = 2, times = ttt[ttt>T0], landmark = T0)
> predCSC_afterT0
     observation X3       X8 times absRisk
  1:           1  0 -0.39410   2.9  0.0761
  2:           2  1 -1.51024   2.9  0.0647
  3:           3  1  0.00599   2.9  0.0417
  4:           4  0  0.85501   2.9  0.0530
  5:           5  0  0.72985   2.9  0.0550
 ---                                      
636:          76  1  0.36861  11.8  0.3184
637:          77  0  0.64851  11.8  0.4514
638:          78  1 -0.43983  11.8  0.3727
639:          79  1 -0.86642  11.8  0.4022
640:          80  0  0.86530  11.8  0.4346
> 
> 
> 
> cleanEx()

detaching ‘package:prodlim’, ‘package:survival’

> nameEx("predict.FGR")
> ### * predict.FGR
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: predict.FGR
> ### Title: Predict subject specific risks (cumulative incidence) based on
> ###   Fine-Gray regression model
> ### Aliases: predict.FGR
> 
> ### ** Examples
> 
> library(prodlim)
> library(survival)
> set.seed(10)
> d <- sampleData(101, outcome = "competing.risk")
> tFun<-function(t) {t}
> fgr<-FGR(Hist(time, event)~X1+strata(X2)+X6+cov2(X7, tf=tFun),
+          data=d, cause=1)
> predictRisk(fgr,times=5,newdata=d[1:10])
            [,1]
 [1,] 0.13299138
 [2,] 0.85169265
 [3,] 0.42770067
 [4,] 0.38976643
 [5,] 0.11350808
 [6,] 0.04557124
 [7,] 0.16149427
 [8,] 0.13046172
 [9,] 0.10263051
[10,] 0.20155413
> 
> 
> 
> cleanEx()

detaching ‘package:survival’, ‘package:prodlim’

> nameEx("predict.riskRegression")
> ### * predict.riskRegression
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: predict.riskRegression
> ### Title: Predict individual risk.
> ### Aliases: predict.riskRegression
> ### Keywords: survival
> 
> ### ** Examples
> 
> 
> data(Melanoma)
> library(prodlim)
> library(survival)
> 
> fit.tarr <- ARR(Hist(time,status)~age+invasion+strata(sex),data=Melanoma,cause=1)
> predict(fit.tarr,newdata=data.frame(age=48,
+                      invasion=factor("level.1",
+                          levels=levels(Melanoma$invasion)),
+                      sex=factor("Female",levels=levels(Melanoma$sex))))
$time
 [1]  227.6000  273.6286  294.5429  388.2857  432.1429  482.7143  557.9143
 [8]  624.2000  643.5714  663.5714  700.5143  743.2571  774.3714  791.8000
[15]  817.0000  835.1429  859.8857  869.7714  904.5714  971.2857  979.5714
[22] 1017.4000 1050.6000 1060.4000 1073.1429 1151.3714 1228.6857 1254.1714
[29] 1279.2000 1347.1429 1461.3714 1510.5714 1533.3714 1555.5429 1577.1429
[36] 1613.6000 1661.7429 1689.3429 1737.8286 1951.2857 2061.2286 2074.8857
[43] 2105.0000 2179.8857 2331.4286 2439.9143 2539.8000 2744.8000 3019.7143
[50] 3338.0000

$risk
  [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14]
1    1    1    1    1    1    1    1    1    1     1     1     1     1     1
  [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24] [,25] [,26] [,27]
1     1     1     1     1     1     1     1     1     1     1     1     1     1
  [,28] [,29] [,30] [,31] [,32] [,33] [,34] [,35] [,36] [,37] [,38] [,39] [,40]
1     1     1     1     1     1     1     1     1     1     1     1     1     1
  [,41] [,42] [,43] [,44] [,45] [,46] [,47] [,48] [,49] [,50]
1     1     1     1     1     1     1     1     1     1     1

attr(,"class")
[1] "predictedRisk"
> predict(fit.tarr,newdata=data.frame(age=48,
+                      invasion=factor("level.1",
+                          levels=levels(Melanoma$invasion)),
+                      sex=factor("Male",levels=levels(Melanoma$sex))))
$time
 [1]  227.6000  273.6286  294.5429  388.2857  432.1429  482.7143  557.9143
 [8]  624.2000  643.5714  663.5714  700.5143  743.2571  774.3714  791.8000
[15]  817.0000  835.1429  859.8857  869.7714  904.5714  971.2857  979.5714
[22] 1017.4000 1050.6000 1060.4000 1073.1429 1151.3714 1228.6857 1254.1714
[29] 1279.2000 1347.1429 1461.3714 1510.5714 1533.3714 1555.5429 1577.1429
[36] 1613.6000 1661.7429 1689.3429 1737.8286 1951.2857 2061.2286 2074.8857
[43] 2105.0000 2179.8857 2331.4286 2439.9143 2539.8000 2744.8000 3019.7143
[50] 3338.0000

$risk
  [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14]
1    1    1    1    1    1    1    1    1    1     1     1     1     1     1
  [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24] [,25] [,26] [,27]
1     1     1     1     1     1     1     1     1     1     1     1     1     1
  [,28] [,29] [,30] [,31] [,32] [,33] [,34] [,35] [,36] [,37] [,38] [,39] [,40]
1     1     1     1     1     1     1     1     1     1     1     1     1     1
  [,41] [,42] [,43] [,44] [,45] [,46] [,47] [,48] [,49] [,50]
1     1     1     1     1     1     1     1     1     1     1

attr(,"class")
[1] "predictedRisk"
> predict(fit.tarr,newdata=data.frame(age=c(48,58,68),
+                      invasion=factor("level.1",
+                          levels=levels(Melanoma$invasion)),
+                      sex=factor("Male",levels=levels(Melanoma$sex))))
$time
 [1]  227.6000  273.6286  294.5429  388.2857  432.1429  482.7143  557.9143
 [8]  624.2000  643.5714  663.5714  700.5143  743.2571  774.3714  791.8000
[15]  817.0000  835.1429  859.8857  869.7714  904.5714  971.2857  979.5714
[22] 1017.4000 1050.6000 1060.4000 1073.1429 1151.3714 1228.6857 1254.1714
[29] 1279.2000 1347.1429 1461.3714 1510.5714 1533.3714 1555.5429 1577.1429
[36] 1613.6000 1661.7429 1689.3429 1737.8286 1951.2857 2061.2286 2074.8857
[43] 2105.0000 2179.8857 2331.4286 2439.9143 2539.8000 2744.8000 3019.7143
[50] 3338.0000

$risk
  [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14]
1    1    1    1    1    1    1    1    1    1     1     1     1     1     1
2    1    1    1    1    1    1    1    1    1     1     1     1     1     1
3    1    1    1    1    1    1    1    1    1     1     1     1     1     1
  [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24] [,25] [,26] [,27]
1     1     1     1     1     1     1     1     1     1     1     1     1     1
2     1     1     1     1     1     1     1     1     1     1     1     1     1
3     1     1     1     1     1     1     1     1     1     1     1     1     1
  [,28] [,29] [,30] [,31] [,32] [,33] [,34] [,35] [,36] [,37] [,38] [,39] [,40]
1     1     1     1     1     1     1     1     1     1     1     1     1     1
2     1     1     1     1     1     1     1     1     1     1     1     1     1
3     1     1     1     1     1     1     1     1     1     1     1     1     1
  [,41] [,42] [,43] [,44] [,45] [,46] [,47] [,48] [,49] [,50]
1     1     1     1     1     1     1     1     1     1     1
2     1     1     1     1     1     1     1     1     1     1
3     1     1     1     1     1     1     1     1     1     1

attr(,"class")
[1] "predictedRisk"
> predict(fit.tarr,newdata=Melanoma[1:4,])
$time
 [1]  227.6000  273.6286  294.5429  388.2857  432.1429  482.7143  557.9143
 [8]  624.2000  643.5714  663.5714  700.5143  743.2571  774.3714  791.8000
[15]  817.0000  835.1429  859.8857  869.7714  904.5714  971.2857  979.5714
[22] 1017.4000 1050.6000 1060.4000 1073.1429 1151.3714 1228.6857 1254.1714
[29] 1279.2000 1347.1429 1461.3714 1510.5714 1533.3714 1555.5429 1577.1429
[36] 1613.6000 1661.7429 1689.3429 1737.8286 1951.2857 2061.2286 2074.8857
[43] 2105.0000 2179.8857 2331.4286 2439.9143 2539.8000 2744.8000 3019.7143
[50] 3338.0000

$risk
  [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14]
1    1    1    1    1    1    1    1    1    1     1     1     1     1     1
2    1    1    1    1    1    1    1    1    1     1     1     1     1     1
3    1    1    1    1    1    1    1    1    1     1     1     1     1     1
4    1    1    1    1    1    1    1    1    1     1     1     1     1     1
  [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24] [,25] [,26] [,27]
1     1     1     1     1     1     1     1     1     1     1     1     1     1
2     1     1     1     1     1     1     1     1     1     1     1     1     1
3     1     1     1     1     1     1     1     1     1     1     1     1     1
4     1     1     1     1     1     1     1     1     1     1     1     1     1
  [,28] [,29] [,30] [,31] [,32] [,33] [,34] [,35] [,36] [,37] [,38] [,39] [,40]
1     1     1     1     1     1     1     1     1     1     1     1     1     1
2     1     1     1     1     1     1     1     1     1     1     1     1     1
3     1     1     1     1     1     1     1     1     1     1     1     1     1
4     1     1     1     1     1     1     1     1     1     1     1     1     1
  [,41] [,42] [,43] [,44] [,45] [,46] [,47] [,48] [,49] [,50]
1     1     1     1     1     1     1     1     1     1     1
2     1     1     1     1     1     1     1     1     1     1
3     1     1     1     1     1     1     1     1     1     1
4     1     1     1     1     1     1     1     1     1     1

attr(,"class")
[1] "predictedRisk"
> 
> 
> 
> 
> cleanEx()

detaching ‘package:survival’, ‘package:prodlim’

> nameEx("predictCox")
> ### * predictCox
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: predictCox
> ### Title: Fast computation of survival probabilities, hazards and
> ###   cumulative hazards from Cox regression models
> ### Aliases: predictCox
> 
> ### ** Examples
> 
> 
> library(survival)
> library(data.table)
> 
> #### generate data ####
> set.seed(10)
> d <- sampleData(40,outcome="survival") ## training dataset
> nd <- sampleData(4,outcome="survival") ## validation dataset
> d$time <- round(d$time,1) ## create tied events
> # table(duplicated(d$time))
> 
> #### stratified Cox model ####
> fit <- coxph(Surv(time,event)~X1 + strata(X2) + X6,
+              data=d, ties="breslow", x = TRUE, y = TRUE)
> 
> ## compute the baseline cumulative hazard
> fit.haz <- predictCox(fit)
> cbind(survival::basehaz(fit), fit.haz$cumhazard)
       hazard time strata fit.haz$cumhazard
1  0.02931158  1.0      0        0.02931158
2  0.04963195  1.8      0        0.04963195
3  0.07065434  2.1      0        0.07065434
4  0.11538240  2.2      0        0.11538240
5  0.13943016  2.5      0        0.13943016
6  0.16963629  2.7      0        0.16963629
7  0.20147775  3.0      0        0.20147775
8  0.20147775  3.2      0        0.20147775
9  0.23924231  3.5      0        0.23924231
10 0.27812921  3.6      0        0.27812921
11 0.32260585  3.7      0        0.32260585
12 0.36980891  4.0      0        0.36980891
13 0.42720764  4.7      0        0.42720764
14 0.42720764  5.1      0        0.42720764
15 0.48812085  5.5      0        0.48812085
16 0.55144168  5.8      0        0.55144168
17 0.62045178  5.9      0        0.62045178
18 0.70101250  6.6      0        0.70101250
19 0.78237932  6.9      0        0.78237932
20 0.78237932  7.0      0        0.78237932
21 0.78237932  7.2      0        0.78237932
22 0.89566220  7.7      0        0.89566220
23 1.08069860  8.4      0        1.08069860
24 1.08069860  9.2      0        1.08069860
25 1.08069860  9.5      0        1.08069860
26 1.08069860  9.6      0        1.08069860
27 1.98002958 11.0      0        1.98002958
28 4.15079877 11.1      0        4.15079877
29 4.15079877 11.5      0        4.15079877
30 9.27508322 12.0      0        9.27508322
31 0.03557926  0.6      1        0.03557926
32 0.16095498  3.6      1        0.16095498
33 0.16095498  4.2      1        0.16095498
34 0.85676310  4.7      1        0.85676310
35 3.07879773  7.5      1        3.07879773
> 
> ## compute individual specific cumulative hazard and survival probabilities 
> fit.pred <- predictCox(fit, newdata=nd, times=c(3,8), se = TRUE, band = TRUE)
> fit.pred
   observation times strata cumhazard cumhazard.se cumhazard.lower
1:           1     3      1    0.3728       0.1390          0.1795
2:           2     3      0    0.0677       0.0382          0.0224
3:           3     3      0    0.1181       0.0541          0.0482
4:           4     3      0    0.2030       0.0750          0.0985
5:           1     8      1        NA           NA              NA
6:           2     8      0    0.3008       0.1401          0.1207
7:           3     8      0    0.5251       0.1885          0.2598
8:           4     8      0    0.9026       0.2504          0.5240
   cumhazard.upper cumhazard.quantileBand cumhazard.lowerBand
1:           0.774                     NA                  NA
2:           0.205                   2.14              0.0202
3:           0.290                   2.17              0.0438
4:           0.419                   2.20              0.0900
5:              NA                     NA                  NA
6:           0.749                   2.14              0.1110
7:           1.061                   2.17              0.2412
8:           1.555                   2.20              0.4899
   cumhazard.upperBand survival survival.se survival.lower survival.upper
1:                  NA    0.689      0.0957          0.461          0.836
2:               0.227    0.935      0.0357          0.815          0.978
3:               0.318    0.889      0.0480          0.749          0.953
4:               0.458    0.816      0.0612          0.658          0.906
5:                  NA       NA          NA             NA             NA
6:               0.815    0.740      0.1037          0.473          0.886
7:               1.143    0.592      0.1115          0.346          0.771
8:               1.663    0.406      0.1016          0.211          0.592
   survival.quantileBand survival.lowerBand survival.upperBand
1:                    NA                 NA                 NA
2:                  2.13              0.798              0.980
3:                  2.16              0.728              0.957
4:                  2.20              0.633              0.914
5:                    NA                 NA                 NA
6:                  2.13              0.444              0.895
7:                  2.16              0.320              0.785
8:                  2.20              0.190              0.612
> 
> ####  other examples ####
> # one strata variable
> fitS <- coxph(Surv(time,event)~strata(X1)+X2,
+               data=d, ties="breslow", x = TRUE, y = TRUE)
> 
> predictCox(fitS)
    times strata cumhazard survival
 1:   0.6      0    0.0256   0.9747
 2:   1.0      0    0.0789   0.9241
 3:   1.8      0    0.1070   0.8986
 4:   2.1      0    0.1358   0.8730
 5:   2.2      0    0.1950   0.8228
 6:   2.5      0    0.2273   0.7967
 7:   2.7      0    0.2607   0.7705
 8:   3.0      0    0.2951   0.7445
 9:   3.2      0    0.2951   0.7445
10:   3.5      0    0.3319   0.7176
11:   3.6      0    0.3700   0.6907
12:   3.7      0    0.4095   0.6640
13:   4.0      0    0.4506   0.6372
14:   4.2      0    0.4506   0.6372
15:   4.7      0    0.5420   0.5816
16:   5.1      0    0.5420   0.5816
17:   5.5      0    0.5962   0.5509
18:   5.8      0    0.6532   0.5204
19:   5.9      0    0.7135   0.4899
20:   6.6      0    0.7815   0.4577
21:   6.9      0    0.8541   0.4256
22:   7.0      0    0.8541   0.4256
23:   7.2      0    0.8541   0.4256
24:   7.5      0    0.9456   0.3885
25:   7.7      0    1.0518   0.3493
26:   8.4      0    1.1698   0.3104
27:   9.2      0    1.1698   0.3104
28:   9.5      0    1.1698   0.3104
29:   9.6      0    1.1698   0.3104
30:  11.0      0    1.4354   0.2380
31:  11.1      0    1.7896   0.1670
32:  11.5      0    1.7896   0.1670
33:  12.0      0    2.8520   0.0577
34:   3.6      1    0.6546   0.5197
    times strata cumhazard survival
> predictCox(fitS, newdata=nd, times = 1)
   observation times strata cumhazard survival
1:           1     1      0    0.1205    0.886
2:           2     1      0    0.0743    0.928
3:           3     1      0    0.0743    0.928
4:           4     1      0    0.0743    0.928
> 
> # two strata variables
> set.seed(1)
> d$U=sample(letters[1:5],replace=TRUE,size=NROW(d))
> d$V=sample(letters[4:10],replace=TRUE,size=NROW(d))
> nd$U=sample(letters[1:5],replace=TRUE,size=NROW(nd))
> nd$V=sample(letters[4:10],replace=TRUE,size=NROW(nd))
> fit2S <- coxph(Surv(time,event)~X1+strata(U)+strata(V)+X2,
+               data=d, ties="breslow", x = TRUE, y = TRUE)
Warning in fitter(X, Y, istrat, offset, init, control, weights = weights,  :
  Loglik converged before variable  1 ; coefficient may be infinite. 
> 
> cbind(survival::basehaz(fit2S),predictCox(fit2S,type="cumhazard")$cumhazard)
         hazard time strata predictCox(fit2S, type = "cumhazard")$cumhazard
1  0.000000e+00  5.9   a, d                                    0.000000e+00
2  0.000000e+00  9.2   a, e                                    0.000000e+00
3  5.773970e-01  1.0   a, g                                    5.773970e-01
4  1.443493e+00  2.5   a, g                                    1.443493e+00
5  1.443493e+00 11.5   a, g                                    1.443493e+00
6  5.773970e-01  0.6   a, h                                    5.773970e-01
7  2.309588e+00  2.7   a, h                                    2.309588e+00
8  4.330478e-01  4.0   a, i                                    4.330478e-01
9  1.010445e+00  4.7   a, i                                    1.010445e+00
10 1.010445e+00  9.6   a, i                                    1.010445e+00
11 1.732191e+00  4.7   a, j                                    1.732191e+00
12 1.732191e+00  3.7   b, d                                    1.732191e+00
13 0.000000e+00  7.2   b, f                                    0.000000e+00
14 1.732191e+00 12.0   b, f                                    1.732191e+00
15 8.660955e-01  2.2   b, g                                    8.660955e-01
16 8.660955e-01  5.1   b, g                                    8.660955e-01
17 8.660955e-01  6.9   b, h                                    8.660955e-01
18 2.598287e+00 11.0   b, h                                    2.598287e+00
19 8.660955e-01  2.1   b, i                                    8.660955e-01
20 8.660955e-01  3.2   b, i                                    8.660955e-01
21 1.732191e+00  6.6   b, j                                    1.732191e+00
22 7.922907e-09  3.6   c, e                                    7.922907e-09
23 1.732191e+00 11.1   c, e                                    1.732191e+00
24 8.660955e-01  1.8   c, i                                    8.660955e-01
25 8.660955e-01  7.0   c, i                                    8.660955e-01
26 0.000000e+00  2.2   d, d                                    0.000000e+00
27 0.000000e+00  9.5   d, d                                    0.000000e+00
28 1.732191e+00  8.4   d, f                                    1.732191e+00
29 1.732191e+00  1.0   d, g                                    1.732191e+00
30 4.330478e-01  5.9   d, h                                    4.330478e-01
31 1.010445e+00  7.5   d, h                                    1.010445e+00
32 2.742636e+00  7.7   d, h                                    2.742636e+00
33 0.000000e+00  4.2   d, j                                    0.000000e+00
34 1.732191e+00  5.8   e, d                                    1.732191e+00
35 1.732191e+00  3.0   e, f                                    1.732191e+00
36 8.660955e-01  3.5   e, i                                    8.660955e-01
37 2.598287e+00  5.5   e, i                                    2.598287e+00
38 5.773970e-01  2.2   e, j                                    5.773970e-01
39 1.443493e+00  3.6   e, j                                    1.443493e+00
40 1.443493e+00  9.2   e, j                                    1.443493e+00
> predictCox(fit2S)
    times strata cumhazard survival
 1:   5.9   a, d  0.00e+00   1.0000
 2:   9.2   a, e  0.00e+00   1.0000
 3:   1.0   a, g  5.77e-01   0.5614
 4:   2.5   a, g  1.44e+00   0.2361
 5:  11.5   a, g  1.44e+00   0.2361
 6:   0.6   a, h  5.77e-01   0.5614
 7:   2.7   a, h  2.31e+00   0.0993
 8:   4.0   a, i  4.33e-01   0.6485
 9:   4.7   a, i  1.01e+00   0.3641
10:   9.6   a, i  1.01e+00   0.3641
11:   4.7   a, j  1.73e+00   0.1769
12:   3.7   b, d  1.73e+00   0.1769
13:   7.2   b, f  0.00e+00   1.0000
14:  12.0   b, f  1.73e+00   0.1769
15:   2.2   b, g  8.66e-01   0.4206
16:   5.1   b, g  8.66e-01   0.4206
17:   6.9   b, h  8.66e-01   0.4206
18:  11.0   b, h  2.60e+00   0.0744
19:   2.1   b, i  8.66e-01   0.4206
20:   3.2   b, i  8.66e-01   0.4206
21:   6.6   b, j  1.73e+00   0.1769
22:   3.6   c, e  7.92e-09   1.0000
23:  11.1   c, e  1.73e+00   0.1769
24:   1.8   c, i  8.66e-01   0.4206
25:   7.0   c, i  8.66e-01   0.4206
26:   2.2   d, d  0.00e+00   1.0000
27:   9.5   d, d  0.00e+00   1.0000
28:   8.4   d, f  1.73e+00   0.1769
29:   1.0   d, g  1.73e+00   0.1769
30:   5.9   d, h  4.33e-01   0.6485
31:   7.5   d, h  1.01e+00   0.3641
32:   7.7   d, h  2.74e+00   0.0644
33:   4.2   d, j  0.00e+00   1.0000
34:   5.8   e, d  1.73e+00   0.1769
35:   3.0   e, f  1.73e+00   0.1769
36:   3.5   e, i  8.66e-01   0.4206
37:   5.5   e, i  2.60e+00   0.0744
38:   2.2   e, j  5.77e-01   0.5614
39:   3.6   e, j  1.44e+00   0.2361
40:   9.2   e, j  1.44e+00   0.2361
    times strata cumhazard survival
> predictCox(fitS, newdata=nd, times = 3)
   observation times strata cumhazard survival
1:           1     3      0     0.451    0.637
2:           2     3      0     0.278    0.757
3:           3     3      0     0.278    0.757
4:           4     3      0     0.278    0.757
> 
> # left truncation
> test2 <- list(start=c(1,2,5,2,1,7,3,4,8,8), 
+               stop=c(2,3,6,7,8,9,9,9,14,17), 
+               event=c(1,1,1,1,1,1,1,0,0,0), 
+               x=c(1,0,0,1,0,1,1,1,0,0)) 
> m.cph <- coxph(Surv(start, stop, event) ~ 1, test2, x = TRUE)
> as.data.table(predictCox(m.cph))
Warning in predictCox(m.cph) :
  The current version of predictCox was not designed to handle left censoring 
The function may be used on own risks 

   times cumhazard  survival
1:     2 0.5000000 0.6065307
2:     3 0.8333333 0.4345982
3:     6 1.0333333 0.3558189
4:     7 1.2833333 0.2771121
5:     8 1.5333333 0.2158151
6:     9 1.9833333 0.1376098
7:    14 1.9833333 0.1376098
8:    17 1.9833333 0.1376098
> 
> basehaz(m.cph)
     hazard time
1 0.5000000    2
2 0.8333333    3
3 1.0333333    6
4 1.2833333    7
5 1.5333333    8
6 1.9833333    9
7 1.9833333   14
8 1.9833333   17
> 
> 
> 
> cleanEx()

detaching ‘package:data.table’, ‘package:survival’

> nameEx("predictCoxPL")
> ### * predictCoxPL
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: predictCoxPL
> ### Title: Computation of survival probabilities from Cox regression models
> ###   using the product limit estimator.
> ### Aliases: predictCoxPL
> 
> ### ** Examples
> 
> library(survival)
> 
> #### generate data ####
> set.seed(10)
> d <- sampleData(40,outcome="survival")
> nd <- sampleData(4,outcome="survival")
> d$time <- round(d$time,1)
> 
> #### Cox model ####
> fit <- coxph(Surv(time,event)~ X1 + X2 + X6,
+              data=d, ties="breslow", x = TRUE, y = TRUE)
> 
> ## exponential approximation
> predictCox(fit, newdata = d, times = 1:5)
     observation times cumhazard survival
  1:           1     1   0.02767 9.73e-01
  2:           2     1   0.01904 9.81e-01
  3:           3     1   0.00346 9.97e-01
  4:           4     1   0.09274 9.11e-01
  5:           5     1   0.01844 9.82e-01
 ---                                     
196:          36     5   3.99435 1.84e-02
197:          37     5   2.10055 1.22e-01
198:          38     5   0.04125 9.60e-01
199:          39     5  29.60459 1.39e-13
200:          40     5   0.68889 5.02e-01
> 
> ## product limit
> predictCoxPL(fit, newdata = d, times = 1:5)
     observation times cumhazard survival
  1:           1     1   0.02767  0.97246
  2:           2     1   0.01904  0.98102
  3:           3     1   0.00346  0.99655
  4:           4     1   0.09274  0.90869
  5:           5     1   0.01844  0.98161
 ---                                     
196:          36     5   3.99435  0.00262
197:          37     5   2.10055  0.08913
198:          38     5   0.04125  0.95949
199:          39     5  29.60459  0.14730
200:          40     5   0.68889  0.48818
> 
> #### stratified Cox model ####
> fitS <- coxph(Surv(time,event)~ X1 + strata(X2) + X6,
+              data=d, ties="breslow", x = TRUE, y = TRUE)
> 
> ## exponential approximation
> predictCox(fitS, newdata = d, times = 1:5)
     observation times strata cumhazard survival
  1:           1     1      0   0.02680 9.74e-01
  2:           2     1      0   0.01885 9.81e-01
  3:           3     1      0   0.00378 9.96e-01
  4:           4     1      0   0.08365 9.20e-01
  5:           5     1      0   0.01830 9.82e-01
 ---                                            
196:          36     5      0   3.62189 2.67e-02
197:          37     5      0   1.97830 1.38e-01
198:          38     5      0   0.04899 9.52e-01
199:          39     5      1  17.24685 3.23e-08
200:          40     5      0   0.69291 5.00e-01
> 
> ## product limit
> predictCoxPL(fitS, newdata = d, times = 1:5)
     observation times strata cumhazard survival
  1:           1     1      0   0.02680    0.973
  2:           2     1      0   0.01885    0.981
  3:           3     1      0   0.00378    0.996
  4:           4     1      0   0.08365    0.916
  5:           5     1      0   0.01830    0.982
 ---                                            
196:          36     5      0   3.62189    0.012
197:          37     5      0   1.97830    0.113
198:          38     5      0   0.04899    0.952
199:          39     5      1  17.24685    5.625
200:          40     5      0   0.69291    0.489
> 
> #### fully stratified Cox model ####
> fitS <- coxph(Surv(time,event)~ 1,
+              data=d, ties="breslow", x = TRUE, y = TRUE)
> 
> ## product limit
> GS <- survfit(Surv(time,event)~1, data = d)
> range(predictCoxPL(fitS)$survival - GS$surv)
[1] 0.000000e+00 1.110223e-16
> 
> fitS <- coxph(Surv(time,event)~ strata(X2),
+              data=d, ties="breslow", x = TRUE, y = TRUE)
> 
> ## product limit
> GS <- survfit(Surv(time,event)~X2, data = d)
> range(predictCoxPL(fitS)$survival - GS$surv)
[1] 0.000000e+00 2.220446e-16
> 
> 
> 
> 
> cleanEx()

detaching ‘package:survival’

> nameEx("predictRisk")
> ### * predictRisk
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: predictRisk
> ### Title: Extrating predicting risks from regression models
> ### Aliases: predictRisk predictRisk.CauseSpecificCox
> ###   predictRisk.riskRegression predictRisk.FGR predictRisk.prodlim
> ###   predictRisk.rfsrc predictRisk.aalen predictRisk.ARR
> ###   predictRisk.cox.aalen predictRisk.coxph predictRisk.cph
> ###   predictRisk.default predictRisk.matrix predictRisk.pecCtree
> ###   predictRisk.pecCforest predictRisk.psm predictRisk.selectCox
> ###   predictRisk.survfit predictRisk.randomForest predictRisk.lrm
> ###   predictRisk.glm predictRisk.rpart predictRisk.gbm
> ###   predictRisk.flexsurvreg predictRisk.double predictRisk.integer
> ###   predictRisk.factor predictRisk.numeric predictRisk.formula
> ###   predictRisk.BinaryTree predictRisk.coxphTD predictRisk.CSCTD
> ###   predictRisk.coxph.penal predictRisk.ranger predictRisk.penfitS3
> ###   predictRisk.SuperPredictor
> ### Keywords: survival
> 
> ### ** Examples
> 
> ## binary outcome
> library(rms)
Loading required package: Hmisc
Loading required package: lattice
Loading required package: survival
Loading required package: Formula
Loading required package: ggplot2

Attaching package: ‘Hmisc’

The following objects are masked from ‘package:base’:

    format.pval, units

Loading required package: SparseM

Attaching package: ‘SparseM’

The following object is masked from ‘package:base’:

    backsolve

> set.seed(7)
> d <- sampleData(80,outcome="binary")
> nd <- sampleData(80,outcome="binary")
> fit <- lrm(Y~X1+X8,data=d)
> predictRisk(fit,newdata=nd)
 [1] 0.7339412 0.5205004 0.6501073 0.5979307 0.5552337 0.6813442 0.5138679
 [8] 0.4869184 0.5723498 0.7074138 0.4503456 0.6303146 0.6940030 0.7019831
[15] 0.7304874 0.5405902 0.6450002 0.6896565 0.6689911 0.6865119 0.7344731
[22] 0.6689586 0.6906598 0.6615316 0.6682134 0.7072245 0.5725908 0.6725140
[29] 0.7493084 0.5723684 0.5466048 0.5498836 0.6665991 0.4635920 0.6969143
[36] 0.5879416 0.5341623 0.6023531 0.5320208 0.6121940 0.5766031 0.4807605
[43] 0.7727554 0.5650180 0.5466259 0.6760755 0.6716273 0.6953790 0.6627699
[50] 0.6865030 0.7738892 0.5867579 0.7673772 0.5591252 0.6120579 0.7014891
[57] 0.5616479 0.6084543 0.5823368 0.4629641 0.5386492 0.7027465 0.6637092
[64] 0.6194466 0.4777845 0.4645041 0.5229923 0.5819439 0.5879641 0.5579212
[71] 0.6642978 0.5665127 0.4391573 0.4995590 0.6802095 0.5770284 0.5952840
[78] 0.5303929 0.5633104 0.7699667
> ## Not run: 
> ##D library(SuperLearner)
> ##D set.seed(1)
> ##D sl = SuperLearner(Y = d$Y, X = d[,-1], family = binomial(),
> ##D       SL.library = c("SL.mean", "SL.glmnet", "SL.randomForest"))
> ## End(Not run)
> 
> ## survival outcome
> # generate survival data
> library(prodlim)
> set.seed(100)
> d <- sampleData(100,outcome="survival")
> d[,X1:=as.numeric(as.character(X1))]
> d[,X2:=as.numeric(as.character(X2))]
> # then fit a Cox model
> library(rms)
> cphmodel <- cph(Surv(time,event)~X1+X2,data=d,surv=TRUE,x=TRUE,y=TRUE)
> # or via survival
> library(survival)
> coxphmodel <- coxph(Surv(time,event)~X1+X2,data=d,x=TRUE,y=TRUE)
> 
> # Extract predicted survival probabilities 
> # at selected time-points:
> ttt <- quantile(d$time)
> # for selected predictor values:
> ndat <- data.frame(X1=c(0.25,0.25,-0.05,0.05),X2=c(0,1,0,1))
> # as follows
> predictRisk(cphmodel,newdata=ndat,times=ttt)
            [,1]      [,2]      [,3]      [,4]      [,5]
[1,] 0.010423552 0.2498546 0.4661259 0.6749391 0.9490180
[2,] 0.011569784 0.2733328 0.5019288 0.7129324 0.9633185
[3,] 0.007190205 0.1796201 0.3509290 0.5387894 0.8712277
[4,] 0.009034264 0.2204172 0.4193263 0.6221600 0.9240581
> predictRisk(coxphmodel,newdata=ndat,times=ttt)
            [,1]      [,2]      [,3]      [,4]      [,5]
[1,] 0.010423555 0.2498546 0.4661259 0.6749389 0.9490178
[2,] 0.011569787 0.2733328 0.5019287 0.7129322 0.9633183
[3,] 0.007190219 0.1796204 0.3509294 0.5387898 0.8712279
[4,] 0.009034276 0.2204174 0.4193266 0.6221602 0.9240581
> 
> # stratified cox model
> sfit <- coxph(Surv(time,event)~strata(X1)+X2,data=d,x=TRUE,y=TRUE)
> predictRisk(sfit,newdata=d[1:3,],times=c(1,3,5,10))
           [,1]     [,2]      [,3]     [,4]
[1,] 0.07654315 0.281073 0.4322176 0.689776
[2,] 0.07654315 0.281073 0.4322176 0.689776
[3,] 0.07654315 0.281073 0.4322176 0.689776
> 
> ## simulate learning and validation data
> learndat <- sampleData(100,outcome="survival")
> valdat <- sampleData(100,outcome="survival")
> ## use the learning data to fit a Cox model
> library(survival)
> fitCox <- coxph(Surv(time,event)~X1+X2,data=learndat,x=TRUE,y=TRUE)
> ## suppose we want to predict the survival probabilities for all subjects
> ## in the validation data at the following time points:
> ## 0, 12, 24, 36, 48, 60
> psurv <- predictRisk(fitCox,newdata=valdat,times=seq(0,60,12))
> ## This is a matrix with event probabilities (1-survival)
> ## one column for each of the 5 time points
> ## one row for each validation set individual
> 
> # Do the same for a randomSurvivalForest model
> # library(randomForestSRC)
> # rsfmodel <- rfsrc(Surv(time,event)~X1+X2,data=learndat)
> # prsfsurv=predictRisk(rsfmodel,newdata=valdat,times=seq(0,60,12))
> # plot(psurv,prsfsurv)
> 
> ## Cox with ridge option
> f1 <- coxph(Surv(time,event)~X1+X2,data=learndat,x=TRUE,y=TRUE)
> f2 <- coxph(Surv(time,event)~ridge(X1)+ridge(X2),data=learndat,x=TRUE,y=TRUE)
> ## Not run: 
> ##D plot(predictRisk(f1,newdata=valdat,times=10),
> ##D      riskRegression:::predictRisk.coxph(f2,newdata=valdat,times=10),
> ##D      xlim=c(0,1),
> ##D      ylim=c(0,1),
> ##D      xlab="Unpenalized predicted survival chance at 10",
> ##D      ylab="Ridge predicted survival chance at 10")
> ## End(Not run)
> 
> ## competing risks
> 
> library(survival)
> library(riskRegression)
> library(prodlim)
> train <- prodlim::SimCompRisk(100)
> test <- prodlim::SimCompRisk(10)
> cox.fit  <- CSC(Hist(time,cause)~X1+X2,data=train)
> predictRisk(cox.fit,newdata=test,times=seq(1:10),cause=1)
             [,1]        [,2]       [,3]       [,4]       [,5]       [,6]
 [1,] 0.003336186 0.006815801 0.01619852 0.02672988 0.04254840 0.06207469
 [2,] 0.031154093 0.062123978 0.14073384 0.21892189 0.31623402 0.40920676
 [3,] 0.002135486 0.004370331 0.01041397 0.01724860 0.02764812 0.04069547
 [4,] 0.015269678 0.031098095 0.07285185 0.11851646 0.18515067 0.26350414
 [5,] 0.071858689 0.141485382 0.30494285 0.45213411 0.61501518 0.74365714
 [6,] 0.008438974 0.017143504 0.04034630 0.06571777 0.10222401 0.14483683
 [7,] 0.019114164 0.038834445 0.09045024 0.14615640 0.22589234 0.31715015
 [8,] 0.012909266 0.026116995 0.06098177 0.09834693 0.15043127 0.20869101
 [9,] 0.088712245 0.169974894 0.35189416 0.49656435 0.62685981 0.70423405
[10,] 0.014431815 0.029407277 0.06897824 0.11238172 0.17598556 0.25122048
            [,7]       [,8]       [,9]     [,10]
 [1,] 0.10014146 0.11107754 0.11107754 0.1566170
 [2,] 0.52199267 0.54231411 0.54231411 0.5854577
 [3,] 0.06697324 0.07473752 0.07473752 0.1084884
 [4,] 0.40501038 0.44254884 0.44254884 0.5868296
 [5,] 0.85808309 0.87165494 0.87165494 0.8886527
 [6,] 0.21937006 0.23879428 0.23879428 0.3087464
 [7,] 0.47403469 0.51371708 0.51371708 0.6569501
 [8,] 0.30273776 0.32546337 0.32546337 0.3987820
 [9,] 0.74636289 0.74893384 0.74893384 0.7499682
[10,] 0.38857610 0.42539186 0.42539186 0.5688372
> 
> ## with strata
> cox.fit2  <- CSC(list(Hist(time,cause)~strata(X1)+X2,Hist(time,cause)~X1+X2),data=train)
> predictRisk(cox.fit2,newdata=test,times=seq(1:10),cause=1)
             [,1]        [,2]        [,3]       [,4]       [,5]       [,6]
 [1,] 0.003408683 0.006817084 0.014309898 0.01918373 0.03858482 0.07252045
 [2,] 0.031858033 0.062417019 0.125586702 0.16409076 0.29136919 0.45125305
 [3,] 0.002183560 0.004372607 0.009202652 0.01235594 0.02508376 0.04776776
 [4,] 0.014921141 0.031035493 0.076679322 0.13563418 0.19232139 0.24677922
 [5,] 0.070581243 0.141808469 0.320150086 0.50265176 0.63413772 0.72648490
 [6,] 0.008612007 0.017146262 0.035664275 0.04755050 0.09280959 0.16678930
 [7,] 0.018683356 0.038764611 0.095183187 0.16690843 0.23453254 0.29813092
 [8,] 0.013172600 0.026136611 0.053982039 0.07166659 0.13690221 0.23793972
 [9,] 0.091973643 0.173528151 0.323325921 0.40329682 0.59785720 0.71952743
[10,] 0.014101554 0.029346853 0.072605636 0.12867447 0.18281979 0.23507918
            [,7]       [,8]       [,9]      [,10]
 [1,] 0.11733823 0.11733823 0.11733823 0.11733823
 [2,] 0.56711144 0.56711144 0.56711144 0.56711144
 [3,] 0.07887777 0.07887777 0.07887777 0.07887777
 [4,] 0.38320640 0.44483827 0.44483827 0.60016503
 [5,] 0.85495833 0.87963912 0.87963912 0.89157834
 [6,] 0.25269590 0.25269590 0.25269590 0.25269590
 [7,] 0.45111926 0.51696557 0.51696557 0.66986176
 [8,] 0.34430205 0.34430205 0.34430205 0.34430205
 [9,] 0.74198812 0.74198812 0.74198812 0.74198812
[10,] 0.36717403 0.42747770 0.42747770 0.58216010
> 
> 
> 
> 
> cleanEx()

detaching ‘package:prodlim’, ‘package:rms’, ‘package:SparseM’,
  ‘package:Hmisc’, ‘package:ggplot2’, ‘package:Formula’,
  ‘package:survival’, ‘package:lattice’

> nameEx("riskLevelPlot")
> ### * riskLevelPlot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: riskLevelPlot
> ### Title: Level plots for risk prediction models
> ### Aliases: riskLevelPlot
> 
> ### ** Examples
> 
> 
> # ---------- logistic regression --------------------
> expit <- function(x){exp(x)/(1+exp(x))}
> partyData <- function(N){
+   Age <- runif(N,.5,15)
+   Parasites <- rnorm(N,mean=3.5-0.03*Age)
+   Fever <- factor(rbinom(N,1,expit(-3.5-.3*Age+.55*Parasites+0.15*Age*Parasites)))
+   data.frame(Fever,Age,Parasites)
+ }
> d <- partyData(100)
> f <- glm(Fever~Age+Parasites,data=d,family="binomial")
> riskLevelPlot(f,Fever~Age+Parasites,d)
> library(randomForest)
randomForest 4.6-14
Type rfNews() to see new features/changes/bug fixes.
> rf <- randomForest(Fever~Age+Parasites,data=d)
> riskLevelPlot(f,Fever~Age+Parasites,d)
> riskLevelPlot(rf,Fever~Age+Parasites,d)
> 
> # ---------- survival analysis --------------------
> 
> # --simulate an artificial data frame
> # with survival response and three predictors
> 
> library(survival)
> library(prodlim)
> set.seed(140515)
> sdat <- sampleData(43,outcome="survival")
> # -- fit a Cox regression model 
> survForm = Surv(time,event) ~ X8 + X9
> cox <- coxph(survForm, data = sdat,x=TRUE)
> 
> # --choose a time horizon for the predictions and plot the risks
> timeHorizon <- floor(median(sdat$time))
> riskLevelPlot(cox, survForm, data = sdat, horizon = timeHorizon)
> 
> # ---------- competing risks --------------------
> 
> # -- simulate an artificial data frame
> # with competing cause response and three predictors
> library(cmprsk)
> library(riskRegression)
> set.seed(140515)
> crdat <- sampleData(49)
> 
> # -- fit a cause-specific Cox regression model
> crForm <- Hist(time,event)~X8+X9
> csCox  <- CSC(crForm, data=crdat)
> 
> # -- choose a time horizon and plot the risk for a given cause
> timeHorizon <- floor(median(crdat$time))
> riskLevelPlot(csCox, crForm, data = crdat, horizon = timeHorizon, cause = 1)
> 
> 
> 
> 
> cleanEx()

detaching ‘package:cmprsk’, ‘package:prodlim’, ‘package:survival’,
  ‘package:randomForest’

> nameEx("riskRegression")
> ### * riskRegression
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: riskRegression
> ### Title: Risk Regression Fits a regression model for the risk of an event
> ###   - allowing for competing risks.
> ### Aliases: riskRegression ARR LRR
> ### Keywords: survival
> 
> ### ** Examples
> 
> 
> library(prodlim)
> data(Melanoma,package="riskRegression")
> ## tumor thickness on the log-scale
> Melanoma$logthick <- log(Melanoma$thick)
> 
> # Single binary factor
> 
> ## absolute risk regression
> library(survival)
> library(prodlim)
> fit.arr <- ARR(Hist(time,status)~sex,data=Melanoma,cause=1)
> print(fit.arr)
Competing risks regression model 

IPCW weights: marginal Kaplan-Meier for the censoring distribution.
Link: 'log' yielding absolute risk ratios
No covariates with time-varying coefficient specified.

Time constant regression coefficients:
 Variable Levels Coef Lower Upper  Pvalue
      sex   Male 1.87  1.17  3.01 0.00927


Note: The coefficients (Coef) are absolute risk ratios 
> # show predicted cumulative incidences
> plot(fit.arr,col=3:4,newdata=data.frame(sex=c("Female","Male")))
> 
> ## compare with non-parametric Aalen-Johansen estimate
> library(prodlim)
> fit.aj <- prodlim(Hist(time,status)~sex,data=Melanoma)
> plot(fit.aj,conf.int=FALSE)
> plot(fit.arr,add=TRUE,col=3:4,newdata=data.frame(sex=c("Female","Male")))
> 
> ## with time-dependent effect
> fit.tarr <- ARR(Hist(time,status)~strata(sex),data=Melanoma,cause=1)
> plot(fit.tarr,newdata=data.frame(sex=c("Female","Male")))
> 
> ## logistic risk regression
> fit.lrr <- LRR(Hist(time,status)~sex,data=Melanoma,cause=1)
> summary(fit.lrr)

riskRegression: Competing risks regression model 

IPCW estimation. The weights are based on
the Kaplan-Meier estimate for the censoring distribution.

Link function: 'logistic' yielding odds ratios, see help(riskRegression).

Covariates with time-varying effects:

 Intercept (numeric)

The effects of these variables depend on time.The column 'Intercept' is the baseline risk where all the covariates have value zero

     (Intercept)
230  "1.013"    
770  "1.064"    
1100 "1.122"    
1700 "1.198"    
3300 "1.431"    

Shown are selected time points, use

plot.riskRegression

to investigate the full shape.


Covariates with time-constant effects:

 sexMale (numeric)

Time constant regression coefficients:

  Factor  Coef exp(Coef) StandardError     z         CI_95   Pvalue
 sexMale 0.832     2.298         0.319 2.605 [1.229;4.298] 0.009184


Note: The values exp(Coef) are odds ratios 
> 
> 
> # Single continuous factor
> 
> ## tumor thickness on the log-scale
> Melanoma$logthick <- log(Melanoma$thick)
> 
> ## absolute risk regression 
> fit2.arr <- ARR(Hist(time,status)~logthick,data=Melanoma,cause=1)
> print(fit2.arr)
Competing risks regression model 

IPCW weights: marginal Kaplan-Meier for the censoring distribution.
Link: 'log' yielding absolute risk ratios
No covariates with time-varying coefficient specified.

Time constant regression coefficients:
 Variable Levels Coef Lower Upper Pvalue
 logthick        1.87  1.49  2.35 <1e-04


Note: The coefficients (Coef) are absolute risk ratios 
> # show predicted cumulative incidences
> plot(fit2.arr,col=1:5,newdata=data.frame(logthick=quantile(Melanoma$logthick)))
> 
> ## comparison with nearest neighbor non-parametric Aalen-Johansen estimate
> library(prodlim)
> fit2.aj <- prodlim(Hist(time,status)~logthick,data=Melanoma)
> plot(fit2.aj,conf.int=FALSE,newdata=data.frame(logthick=quantile(Melanoma$logthick)))
> plot(fit2.arr,add=TRUE,col=1:5,lty=3,newdata=data.frame(logthick=quantile(Melanoma$logthick)))
> 
> ## logistic risk regression
> fit2.lrr <- LRR(Hist(time,status)~logthick,data=Melanoma,cause=1)
> summary(fit2.lrr)

riskRegression: Competing risks regression model 

IPCW estimation. The weights are based on
the Kaplan-Meier estimate for the censoring distribution.

Link function: 'logistic' yielding odds ratios, see help(riskRegression).

Covariates with time-varying effects:

 Intercept (numeric)

The effects of these variables depend on time.The column 'Intercept' is the baseline risk where all the covariates have value zero

     (Intercept)
230  "1.007"    
770  "1.040"    
1100 "1.074"    
1700 "1.120"    
3300 "1.283"    

Shown are selected time points, use

plot.riskRegression

to investigate the full shape.


Covariates with time-constant effects:

 logthick (numeric)

Time constant regression coefficients:

   Factor  Coef exp(Coef) StandardError     z         CI_95  Pvalue
 logthick 1.003     2.726         0.214 4.677 [1.790;4.149] < 1e-04


Note: The values exp(Coef) are odds ratios 
> 
> ## change model for censoring weights
> library(rms)
Loading required package: Hmisc
Loading required package: lattice
Loading required package: Formula
Loading required package: ggplot2

Attaching package: ‘Hmisc’

The following objects are masked from ‘package:base’:

    format.pval, units

Loading required package: SparseM

Attaching package: ‘SparseM’

The following object is masked from ‘package:base’:

    backsolve

> fit2a.lrr <- LRR(Hist(time,status)~logthick,
+                  data=Melanoma,
+                  cause=1,
+                  cens.model="cox",
+                  cens.formula=~sex+epicel+ulcer+age+logthick)
> summary(fit2a.lrr)

riskRegression: Competing risks regression model 

IPCW estimation. The weights are based on
a Cox model for the censoring distribution.

Link function: 'logistic' yielding odds ratios, see help(riskRegression).

Covariates with time-varying effects:

 Intercept (numeric)

The effects of these variables depend on time.The column 'Intercept' is the baseline risk where all the covariates have value zero

     (Intercept)
230  "1.007"    
770  "1.040"    
1100 "1.074"    
1700 "1.120"    
3300 "1.283"    

Shown are selected time points, use

plot.riskRegression

to investigate the full shape.


Covariates with time-constant effects:

 logthick (numeric)

Time constant regression coefficients:

   Factor  Coef exp(Coef) StandardError     z         CI_95  Pvalue
 logthick 1.003     2.726         0.214 4.677 [1.790;4.149] < 1e-04


Note: The values exp(Coef) are odds ratios 
> 
> ##  compare prediction performance
> Score(list(ARR=fit2.arr,AJ=fit2.aj,LRR=fit2.lrr),formula=Hist(time,status)~1,data=Melanoma)

Metric AUC:

Results by model:

   model times  AUC lower upper
1:   ARR  2006 60.0  55.5  64.5
2:    AJ  2006 72.6  64.4  80.9
3:   LRR  2006 73.8  65.6  82.0

Results of model comparisons:

   times model reference delta.AUC lower upper     p
1:  2006    AJ       ARR      12.6   5.1  20.1 9e-04
2:  2006   LRR       ARR      13.8   6.4  21.2 3e-04
3:  2006   LRR        AJ       1.2  -0.5   2.9 2e-01

NOTE: Values are multiplied by 100 and given in % (use print(...,percent=FALSE) to avoid this.

NOTE: The higher AUC the better.

Metric Brier:

Results by model:

        model times Brier lower upper
1: Null model  2006  17.7  13.4  22.0
2:        ARR  2006  68.9  63.0  74.9
3:         AJ  2006  15.9  12.3  19.4
4:        LRR  2006  34.8  30.9  38.8

Results of model comparisons:

   times model  reference delta.Brier lower upper            p
1:  2006   ARR Null model        51.2  42.1  60.3 2.028954e-28
2:  2006    AJ Null model        -1.9  -3.9   0.2 7.686697e-02
3:  2006   LRR Null model        17.1  10.5  23.7 3.785925e-07
4:  2006    AJ        ARR       -53.1 -61.2 -44.9 2.424144e-37
5:  2006   LRR        ARR       -34.1 -38.1 -30.1 1.616407e-62
6:  2006   LRR         AJ        19.0  13.7  24.2 1.290679e-12

NOTE: Values are multiplied by 100 and given in % (use print(...,percent=FALSE) to avoid this.

NOTE: The lower Brier the better.
> 
> 
> # multiple regression
> library(riskRegression)
> library(prodlim)
> # absolute risk model
> multi.arr <- ARR(Hist(time,status)~logthick+sex+age+ulcer,data=Melanoma,cause=1)
> 
> # stratified model allowing different baseline risk for the two gender
> multi.arr <- ARR(Hist(time,status)~thick+strata(sex)+age+ulcer,data=Melanoma,cause=1)
> 
> # stratify by a continuous variable: strata(age)
> multi.arr <- ARR(Hist(time,status)~tp(thick,power=0)+strata(age)+sex+ulcer,
+                  data=Melanoma,
+                  cause=1)
> 
> fit.arr2a <- ARR(Hist(time,status)~tp(thick,power=1),data=Melanoma,cause=1)
> summary(fit.arr2a)

riskRegression: Competing risks regression model 

IPCW estimation. The weights are based on
the Kaplan-Meier estimate for the censoring distribution.

Link function: 'relative' yielding absolute risk ratios, see help(riskRegression).

Covariates with time-varying effects:

 Intercept (numeric)

The effects of these variables depend on time.The column 'Intercept' is the baseline risk where all the covariates have value zero

     (Intercept)
230  "1.015"    
770  "1.082"    
1100 "1.145"    
1700 "1.195"    
3300 "1.156"    

Shown are selected time points, use

plot.riskRegression

to investigate the full shape.


Covariates with time-constant effects:

 thick (numeric)

Time constant regression coefficients:

 Factor     Coef exp(Coef) StandardError        z         CI_95  Pvalue
  thick 4.44e-05  1.00e+00      7.33e-06 6.05e+00 [1.000;1.000] < 1e-04


Note: The values exp(Coef) are absolute risk ratios 


Note:The coeffient(s) for the following variable(s)
thick are interpreted as per factor unit multiplied by time^power.
> fit.arr2b <- ARR(Hist(time,status)~timevar(thick),data=Melanoma,cause=1)
> summary(fit.arr2b)

riskRegression: Competing risks regression model 

IPCW estimation. The weights are based on
the Kaplan-Meier estimate for the censoring distribution.

Link function: 'relative' yielding absolute risk ratios, see help(riskRegression).

Covariates with time-varying effects:

 Intercept (numeric)
 thick (numeric)

The effects of these variables depend on time.The column 'Intercept' is the baseline risk where all the covariates have value zero

     (Intercept) thick  
230  "0.993"     "1.008"
770  "0.984"     "1.033"
1100 "1.022"     "1.042"
1700 "1.066"     "1.050"
3300 "1.241"     "1.043"

Shown are selected time points, use

plot.riskRegression

to investigate the full shape.


Time constant regression coefficients:

No covariates with time-constant coefficients specified.
> 
> ## logistic risk model
> fit.lrr <- LRR(Hist(time,status)~thick,data=Melanoma,cause=1)
> summary(fit.lrr)

riskRegression: Competing risks regression model 

IPCW estimation. The weights are based on
the Kaplan-Meier estimate for the censoring distribution.

Link function: 'logistic' yielding odds ratios, see help(riskRegression).

Covariates with time-varying effects:

 Intercept (numeric)

The effects of these variables depend on time.The column 'Intercept' is the baseline risk where all the covariates have value zero

     (Intercept)
230  "1.007"    
770  "1.050"    
1100 "1.098"    
1700 "1.158"    
3300 "1.347"    

Shown are selected time points, use

plot.riskRegression

to investigate the full shape.


Covariates with time-constant effects:

 thick (numeric)

Time constant regression coefficients:

 Factor   Coef exp(Coef) StandardError      z         CI_95  Pvalue
  thick 0.1942    1.2143        0.0477 4.0690 [1.106;1.333] < 1e-04


Note: The values exp(Coef) are odds ratios 
> 
> 
> 
> 
> 
> ## nearest neighbor non-parametric Aalen-Johansen estimate
> library(prodlim)
> fit.aj <- prodlim(Hist(time,status)~thick,data=Melanoma)
> plot(fit.aj,conf.int=FALSE)
> 
> # prediction performance
> x <- Score(list(fit.arr2a,fit.arr2b,fit.lrr),
+              data=Melanoma,
+              formula=Hist(time,status)~1,
+              cause=1,
+              split.method="none")
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:rms’, ‘package:SparseM’, ‘package:Hmisc’,
  ‘package:ggplot2’, ‘package:Formula’, ‘package:lattice’,
  ‘package:survival’, ‘package:prodlim’

> nameEx("riskRegression.options")
> ### * riskRegression.options
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: riskRegression.options
> ### Title: Global options for 'riskRegression'
> ### Aliases: riskRegression.options
> 
> ### ** Examples
> 
> options <- riskRegression.options()
> 
> ## add new method.predictRiskIID
> riskRegression.options(method.predictRiskIID = c(options$method.predictRiskIID,"xx"))
> 
> riskRegression.options()
$method.predictRisk
 [1] "predictRisk.ARR"              "predictRisk.BinaryTree"      
 [3] "predictRisk.CauseSpecificCox" "predictRisk.Cforest"         
 [5] "predictRisk.coxph"            "predictRisk.coxph.penal"     
 [7] "predictRisk.coxphTD"          "predictRisk.cph"             
 [9] "predictRisk.CSCTD"            "predictRisk.Ctree"           
[11] "predictRisk.default"          "predictRisk.double"          
[13] "predictRisk.factor"           "predictRisk.FGR"             
[15] "predictRisk.flexsurvreg"      "predictRisk.formula"         
[17] "predictRisk.gbm"              "predictRisk.glm"             
[19] "predictRisk.integer"          "predictRisk.lrm"             
[21] "predictRisk.matrix"           "predictRisk.numeric"         
[23] "predictRisk.penfitS3"         "predictRisk.prodlim"         
[25] "predictRisk.psm"              "predictRisk.randomForest"    
[27] "predictRisk.ranger"           "predictRisk.rfsrc"           
[29] "predictRisk.riskRegression"   "predictRisk.rpart"           
[31] "predictRisk.selectCox"        "predictRisk.SmcFcs"          
[33] "predictRisk.SuperPredictor"   "predictRisk.survfit"         

$method.predictRiskIID
[1] "predictRiskIID.CauseSpecificCox" "predictRiskIID.coxph"           
[3] "predictRiskIID.cph"              "predictRiskIID.default"         
[5] "predictRiskIID.glm"              "predictRiskIID.phreg"           
[7] "xx"                             

> 
> 
> 
> cleanEx()
> nameEx("rowCenter_cpp")
> ### * rowCenter_cpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rowCenter_cpp
> ### Title: Apply - by row
> ### Aliases: rowCenter_cpp
> 
> ### ** Examples
> 
> x <- matrix(1,6,5)
> sweep(x, MARGIN = 2, FUN = "-", STATS = 1:5)
     [,1] [,2] [,3] [,4] [,5]
[1,]    0   -1   -2   -3   -4
[2,]    0   -1   -2   -3   -4
[3,]    0   -1   -2   -3   -4
[4,]    0   -1   -2   -3   -4
[5,]    0   -1   -2   -3   -4
[6,]    0   -1   -2   -3   -4
> rowCenter_cpp(x, 1:5 )
     [,1] [,2] [,3] [,4] [,5]
[1,]    0   -1   -2   -3   -4
[2,]    0   -1   -2   -3   -4
[3,]    0   -1   -2   -3   -4
[4,]    0   -1   -2   -3   -4
[5,]    0   -1   -2   -3   -4
[6,]    0   -1   -2   -3   -4
> 
> rowCenter_cpp(x, colMeans(x) )
     [,1] [,2] [,3] [,4] [,5]
[1,]    0    0    0    0    0
[2,]    0    0    0    0    0
[3,]    0    0    0    0    0
[4,]    0    0    0    0    0
[5,]    0    0    0    0    0
[6,]    0    0    0    0    0
> 
> 
> 
> cleanEx()
> nameEx("rowCumProd")
> ### * rowCumProd
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rowCumProd
> ### Title: Apply cumprod in each row
> ### Aliases: rowCumProd
> 
> ### ** Examples
> 
> x <- matrix(1:8,ncol=2)
> rowCumProd(x)
     [,1] [,2]
[1,]    1    5
[2,]    2   12
[3,]    3   21
[4,]    4   32
> 
> 
> 
> cleanEx()
> nameEx("rowCumSum")
> ### * rowCumSum
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rowCumSum
> ### Title: Apply cumsum in each row
> ### Aliases: rowCumSum
> 
> ### ** Examples
> 
> x <- matrix(1:8,ncol=2)
> rowCumSum(x)
     [,1] [,2]
[1,]    1    6
[2,]    2    8
[3,]    3   10
[4,]    4   12
> 
> 
> 
> cleanEx()
> nameEx("rowMultiply_cpp")
> ### * rowMultiply_cpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rowMultiply_cpp
> ### Title: Apply * by row
> ### Aliases: rowMultiply_cpp
> 
> ### ** Examples
> 
> x <- matrix(1,6,5)
> sweep(x, MARGIN = 2, FUN = "*", STATS = 1:5)
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    2    3    4    5
[2,]    1    2    3    4    5
[3,]    1    2    3    4    5
[4,]    1    2    3    4    5
[5,]    1    2    3    4    5
[6,]    1    2    3    4    5
> rowMultiply_cpp(x, 1:5 )
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    2    3    4    5
[2,]    1    2    3    4    5
[3,]    1    2    3    4    5
[4,]    1    2    3    4    5
[5,]    1    2    3    4    5
[6,]    1    2    3    4    5
> 
> rowMultiply_cpp(x, 1/colMeans(x) )
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    1    1    1    1
[2,]    1    1    1    1    1
[3,]    1    1    1    1    1
[4,]    1    1    1    1    1
[5,]    1    1    1    1    1
[6,]    1    1    1    1    1
> 
> 
> 
> 
> cleanEx()
> nameEx("rowPaste")
> ### * rowPaste
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rowPaste
> ### Title: Collapse Rows of Characters.
> ### Aliases: rowPaste
> 
> ### ** Examples
> 
> ## Not run: 
> ##D M <- matrix(letters,nrow = 26, ncol = 2)
> ##D rowPaste(M)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("rowScale_cpp")
> ### * rowScale_cpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rowScale_cpp
> ### Title: Apply / by row
> ### Aliases: rowScale_cpp
> 
> ### ** Examples
> 
> x <- matrix(1,6,5)
> sweep(x, MARGIN = 2, FUN = "/", STATS = 1:5)
     [,1] [,2]      [,3] [,4] [,5]
[1,]    1  0.5 0.3333333 0.25  0.2
[2,]    1  0.5 0.3333333 0.25  0.2
[3,]    1  0.5 0.3333333 0.25  0.2
[4,]    1  0.5 0.3333333 0.25  0.2
[5,]    1  0.5 0.3333333 0.25  0.2
[6,]    1  0.5 0.3333333 0.25  0.2
> rowScale_cpp(x, 1:5 )
     [,1] [,2]      [,3] [,4] [,5]
[1,]    1  0.5 0.3333333 0.25  0.2
[2,]    1  0.5 0.3333333 0.25  0.2
[3,]    1  0.5 0.3333333 0.25  0.2
[4,]    1  0.5 0.3333333 0.25  0.2
[5,]    1  0.5 0.3333333 0.25  0.2
[6,]    1  0.5 0.3333333 0.25  0.2
> 
> rowScale_cpp(x, colMeans(x) )
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    1    1    1    1
[2,]    1    1    1    1    1
[3,]    1    1    1    1    1
[4,]    1    1    1    1    1
[5,]    1    1    1    1    1
[6,]    1    1    1    1    1
> 
> 
> 
> cleanEx()
> nameEx("rowSumsCrossprod")
> ### * rowSumsCrossprod
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rowSumsCrossprod
> ### Title: Apply crossprod and rowSums
> ### Aliases: rowSumsCrossprod
> 
> ### ** Examples
> 
> x <- matrix(1:10,nrow=5)
> y <- matrix(1:20,ncol=4)
> rowSumsCrossprod(x,y,0)
     [,1] [,2] [,3] [,4]
[1,]  185  460  735 1010
> 
> x <- matrix(1:10,nrow=5)
> y <- matrix(1:20,ncol=5)
> rowSumsCrossprod(x,y,1)
     [,1] [,2] [,3] [,4]
[1,]  575  630  685  740
> 
> 
> 
> cleanEx()
> nameEx("sampleData")
> ### * sampleData
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sampleData
> ### Title: Simulate data with binary or time-to-event outcome
> ### Aliases: sampleData sampleDataTD
> 
> ### ** Examples
> 
> sampleData(10,outcome="binary")
          X6       X7         X8         X9         X10 X1 X2 X3 X4 X5 Y
 1: 62.83188 69.90200 -0.7074952 -0.4149946 -0.05612874  0  0  1  0  0 1
 2: 32.92562 58.16389  0.3645820 -0.3942900 -0.15579551  0  0  0  0  0 0
 3: 81.98332 54.77933  0.7685329 -0.0593134 -1.47075238  0  0  0  1  1 1
 4: 62.29880 62.84860 -0.1123462  1.1000254 -0.47815006  0  0  0  0  1 0
 5: 92.58918 59.32473  0.8811077  0.7631757  0.41794156  0  1  0  1  0 1
 6: 67.13264 72.00809  0.3981059 -0.1645236  1.35867955  0  0  0  0  1 0
 7: 49.35080 59.80380 -0.6120264 -0.2533617 -0.10278773  0  0  0  1  1 0
 8: 69.16090 63.44870  0.3411197  0.6969634  0.38767161  0  0  0  1  1 1
 9: 45.98854 60.14001 -1.1293631  0.5566632 -0.05380504  0  0  1  0  1 0
10: 41.19550 56.28363  1.4330237 -0.6887557 -1.37705956  0  0  0  1  0 0
> sampleData(10,outcome="survival")
          X6       X7          X8          X9        X10 X1 X2 X3 X4 X5
 1: 66.75281 50.42820  0.06016044 -0.50595746 -0.6357365  1  0  1  0  1
 2: 59.72160 65.88292 -0.58889449  1.34303883 -0.4616447  0  0  0  0  1
 3: 55.22897 51.67514  0.53149619 -0.21457941  1.4322822  0  0  0  1  1
 4: 46.05957 57.68235 -1.51839408 -0.17955653 -0.6506964  1  0  1  0  0
 5: 37.68810 54.42040  0.30655786 -0.10019074 -0.2073807  0  0  0  1  0
 6: 43.87212 56.24590 -1.53644982  0.71266631 -0.3928079  0  0  0  0  1
 7: 75.00043 70.43583 -0.30097613 -0.07356440 -0.3199929  0  0  0  1  1
 8: 50.68100 60.08698 -0.52827990 -0.03763417 -0.2791133  1  0  1  1  1
 9: 39.23360 53.56850 -0.65209478 -0.68166048  0.4941883  1  0  0  1  1
10: 88.03936 51.79697 -0.05689678 -0.32427027 -0.1773305  0  0  1  0  1
     eventtime  censtime      time event
 1:  0.6510013 11.207147 0.6510013     1
 2: 33.2805894  3.329060 3.3290603     0
 3:  6.2541901  8.982810 6.2541901     1
 4:  0.4511434  4.984784 0.4511434     1
 5:  8.0470010  3.565532 3.5655318     0
 6:  8.4900270  9.402165 8.4900270     1
 7:  3.7712936 16.588759 3.7712936     1
 8:  2.6758020 10.450697 2.6758020     1
 9:  7.2375769  5.686321 5.6863212     0
10:  0.6010126 10.420404 0.6010126     1
> sampleData(10,outcome="competing.risks")
          X6       X7          X8          X9         X10 X1 X2 X3 X4 X5
 1: 70.60966 55.07087 -1.73321841 -0.16437583  0.40940184  0  0  0  0  0
 2: 75.51162 45.55540  0.00213186  0.42069464  1.68887329  0  0  0  0  0
 3: 63.35221 56.79759 -0.63030033 -0.40024674  1.58658843  1  0  1  1  1
 4: 46.81939 62.85254 -0.34096858 -1.37020788 -0.33090780  0  1  0  0  0
 5: 77.44447 59.70138 -1.15657236  0.98783827 -2.28523554  0  0  0  0  1
 6: 29.99753 59.50911  1.80314191  1.51974503  2.49766159  0  0  0  1  0
 7: 51.82814 62.80410 -0.33113204 -0.30874057  0.66706617  0  0  0  0  1
 8: 56.16494 54.06771 -1.60551341 -1.25328976  0.54132734  0  1  1  1  0
 9: 57.50818 65.48389  0.19719344  0.64224131 -0.01339952  0  0  0  1  1
10: 75.30696 59.97328  0.26317565 -0.04470914  0.51010842  0  1  0  0  0
    eventtime1 eventtime2  censtime      time event
 1:   5.018722   1.027409  1.174009  1.027409     2
 2:   1.685831  13.170825 11.070312  1.685831     1
 3:   1.345442   7.824632  9.580784  1.345442     1
 4:   7.969699   9.779170  4.561721  4.561721     0
 5:   7.805580   6.255554 16.006193  6.255554     2
 6:  10.480238  11.454049 10.057011 10.057011     0
 7:  15.380297   8.698377  9.028321  8.698377     2
 8:   2.415957  13.271864 13.613713  2.415957     1
 9:  10.326071   9.982211  7.354809  7.354809     0
10:   3.432267   5.665905  1.740460  1.740460     0
> 
> 
> 
> cleanEx()
> nameEx("selectCox")
> ### * selectCox
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: selectCox
> ### Title: Backward variable selection in the Cox regression model
> ### Aliases: selectCox
> ### Keywords: survival
> 
> ### ** Examples
> 
> 
> library(pec)
Loading required package: prodlim

Attaching package: ‘pec’

The following objects are masked from ‘package:riskRegression’:

    ipcw, selectCox

> library(prodlim)
> data(GBSG2)
> library(survival)
> f <- selectCox(Surv(time,cens)~horTh+age+menostat+tsize+tgrade+pnodes+progrec+estrec ,
+ 	       data=GBSG2)
> 
> 
> 
> 
> cleanEx()

detaching ‘package:survival’, ‘package:pec’, ‘package:prodlim’

> nameEx("simActiveSurveillance")
> ### * simActiveSurveillance
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: simActiveSurveillance
> ### Title: Simulate data of a hypothetical active surveillance prostate
> ###   cancer study
> ### Aliases: simActiveSurveillance
> 
> ### ** Examples
> 
> set.seed(71)
> simActiveSurveillance(3)
        age   lpsaden     ppb5     lmax ct1 diaggs erg.status     time event
1: 68.04504 -3.504668 2.024705 1.077346 cT1    3/3        neg 4.047567     0
2: 68.45207 -3.696001 5.321986 4.231017 cT1    3/3        pos 1.603210     1
3: 70.81464 -3.082855 3.428400 2.042447 cT1    GNA        neg 5.566821     0
> 
> 
> 
> cleanEx()
> nameEx("simMelanoma")
> ### * simMelanoma
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: simMelanoma
> ### Title: Simulate data alike the Melanoma data
> ### Aliases: simMelanoma
> 
> ### ** Examples
> 
> set.seed(71)
> simMelanoma(3)
         ulcer      epicel  sex      age  logthick     thick       time status
1: not present     present Male 67.63431 -1.384208 0.2505222 3076.04823      0
2:     present not present Male 57.92951  1.446500 4.2482183 2179.31190      1
3:     present     present Male 60.48275  2.287579 9.8510608   25.85244      1
   ici
1:   0
2:   0
3:   3
> 
> 
> 
> cleanEx()
> nameEx("sliceMultiply_cpp")
> ### * sliceMultiply_cpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sliceMultiply_cpp
> ### Title: Apply * by slice
> ### Aliases: sliceMultiply_cpp sliceMultiplyPointer_cpp
> 
> ### ** Examples
> 
> x <- array(1, dim = c(2,6,5))
> M <- matrix(1:12,2,6)
> sweep(x, MARGIN = 1:2, FUN = "*", STATS = M)
, , 1

     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    3    5    7    9   11
[2,]    2    4    6    8   10   12

, , 2

     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    3    5    7    9   11
[2,]    2    4    6    8   10   12

, , 3

     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    3    5    7    9   11
[2,]    2    4    6    8   10   12

, , 4

     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    3    5    7    9   11
[2,]    2    4    6    8   10   12

, , 5

     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    3    5    7    9   11
[2,]    2    4    6    8   10   12

> sliceMultiply_cpp(x, M) 
, , 1

     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    3    5    7    9   11
[2,]    2    4    6    8   10   12

, , 2

     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    3    5    7    9   11
[2,]    2    4    6    8   10   12

, , 3

     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    3    5    7    9   11
[2,]    2    4    6    8   10   12

, , 4

     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    3    5    7    9   11
[2,]    2    4    6    8   10   12

, , 5

     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    3    5    7    9   11
[2,]    2    4    6    8   10   12

> 
> 
> 
> 
> cleanEx()
> nameEx("sliceScale_cpp")
> ### * sliceScale_cpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sliceScale_cpp
> ### Title: Apply / by slice
> ### Aliases: sliceScale_cpp sliceScalePointer_cpp
> 
> ### ** Examples
> 
> x <- array(1, dim = c(2,6,5))
> M <- matrix(1:12,2,6)
> sweep(x, MARGIN = 1:2, FUN = "/", STATS = M)
, , 1

     [,1]      [,2]      [,3]      [,4]      [,5]       [,6]
[1,]  1.0 0.3333333 0.2000000 0.1428571 0.1111111 0.09090909
[2,]  0.5 0.2500000 0.1666667 0.1250000 0.1000000 0.08333333

, , 2

     [,1]      [,2]      [,3]      [,4]      [,5]       [,6]
[1,]  1.0 0.3333333 0.2000000 0.1428571 0.1111111 0.09090909
[2,]  0.5 0.2500000 0.1666667 0.1250000 0.1000000 0.08333333

, , 3

     [,1]      [,2]      [,3]      [,4]      [,5]       [,6]
[1,]  1.0 0.3333333 0.2000000 0.1428571 0.1111111 0.09090909
[2,]  0.5 0.2500000 0.1666667 0.1250000 0.1000000 0.08333333

, , 4

     [,1]      [,2]      [,3]      [,4]      [,5]       [,6]
[1,]  1.0 0.3333333 0.2000000 0.1428571 0.1111111 0.09090909
[2,]  0.5 0.2500000 0.1666667 0.1250000 0.1000000 0.08333333

, , 5

     [,1]      [,2]      [,3]      [,4]      [,5]       [,6]
[1,]  1.0 0.3333333 0.2000000 0.1428571 0.1111111 0.09090909
[2,]  0.5 0.2500000 0.1666667 0.1250000 0.1000000 0.08333333

> sliceScale_cpp(x, M) 
, , 1

     [,1]      [,2]      [,3]      [,4]      [,5]       [,6]
[1,]  1.0 0.3333333 0.2000000 0.1428571 0.1111111 0.09090909
[2,]  0.5 0.2500000 0.1666667 0.1250000 0.1000000 0.08333333

, , 2

     [,1]      [,2]      [,3]      [,4]      [,5]       [,6]
[1,]  1.0 0.3333333 0.2000000 0.1428571 0.1111111 0.09090909
[2,]  0.5 0.2500000 0.1666667 0.1250000 0.1000000 0.08333333

, , 3

     [,1]      [,2]      [,3]      [,4]      [,5]       [,6]
[1,]  1.0 0.3333333 0.2000000 0.1428571 0.1111111 0.09090909
[2,]  0.5 0.2500000 0.1666667 0.1250000 0.1000000 0.08333333

, , 4

     [,1]      [,2]      [,3]      [,4]      [,5]       [,6]
[1,]  1.0 0.3333333 0.2000000 0.1428571 0.1111111 0.09090909
[2,]  0.5 0.2500000 0.1666667 0.1250000 0.1000000 0.08333333

, , 5

     [,1]      [,2]      [,3]      [,4]      [,5]       [,6]
[1,]  1.0 0.3333333 0.2000000 0.1428571 0.1111111 0.09090909
[2,]  0.5 0.2500000 0.1666667 0.1250000 0.1000000 0.08333333

> 
> 
> 
> 
> cleanEx()
> nameEx("subjectWeights")
> ### * subjectWeights
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: subjectWeights
> ### Title: Estimation of censoring probabilities at subject specific times
> ### Aliases: subjectWeights subjectWeights.none subjectWeights.km
> ###   subjectWeights.marginal subjectWeights.nonpar subjectWeights.cox
> ###   subjectWeights.aalen
> ### Keywords: survival
> 
> ### ** Examples
> 
> 
> library(prodlim)
> library(survival)
> dat=SimSurv(300)
> 
> dat <- dat[order(dat$time,-dat$status),]
> 
> # using the marginal Kaplan-Meier for the censoring times
> 
> WKM=subjectWeights(Hist(time,status)~X2,data=dat,method="marginal")
> plot(WKM$fit)
> WKM$fit

Call: prodlim::prodlim(formula = formula, data = data, reverse = TRUE)

Kaplan-Meier estimator for the censoring time survival function

No covariates

Right-censored response of a survival model

No.Observations: 300 

Pattern:
                Freq
 event          186 
 right.censored 114 
> WKM$weights
  [1] 1.00000000 0.99666667 0.99666667 0.99332215 0.99332215 0.99332215
  [7] 0.99332215 0.98994350 0.98994350 0.98994350 0.98654163 0.98313977
 [13] 0.98313977 0.98313977 0.98313977 0.98313977 0.97969015 0.97969015
 [19] 0.97969015 0.97969015 0.97620371 0.97620371 0.97620371 0.97620371
 [25] 0.97620371 0.97620371 0.97620371 0.97620371 0.97620371 0.97620371
 [31] 0.97260148 0.96899926 0.96539703 0.96539703 0.96539703 0.96539703
 [37] 0.96539703 0.96174022 0.96174022 0.96174022 0.95805539 0.95805539
 [43] 0.95805539 0.95805539 0.95805539 0.95805539 0.95805539 0.95428352
 [49] 0.95428352 0.95428352 0.95428352 0.95428352 0.95045106 0.95045106
 [55] 0.94660308 0.94660308 0.94660308 0.94660308 0.94660308 0.94269149
 [61] 0.93877991 0.93877991 0.93877991 0.93483546 0.93483546 0.93483546
 [67] 0.93483546 0.93084043 0.92684541 0.92684541 0.92283309 0.92283309
 [73] 0.91880325 0.91477341 0.91477341 0.91477341 0.91477341 0.91477341
 [79] 0.91067129 0.91067129 0.91067129 0.90653188 0.90653188 0.90653188
 [85] 0.90235431 0.90235431 0.90235431 0.90235431 0.90235431 0.89809792
 [91] 0.89384153 0.88958515 0.88958515 0.88958515 0.88958515 0.88958515
 [97] 0.88524571 0.88524571 0.88088489 0.88088489 0.88088489 0.87648047
[103] 0.87207604 0.86767162 0.86767162 0.86767162 0.86767162 0.86319908
[109] 0.85872655 0.85872655 0.85872655 0.85420694 0.85420694 0.85420694
[115] 0.85420694 0.85420694 0.85420694 0.85420694 0.84953914 0.84487134
[121] 0.84487134 0.84487134 0.84487134 0.84487134 0.84487134 0.84487134
[127] 0.84487134 0.84487134 0.83998769 0.83510404 0.83022039 0.82533674
[133] 0.82533674 0.82042402 0.82042402 0.82042402 0.82042402 0.82042402
[139] 0.81539075 0.81035747 0.81035747 0.81035747 0.80526088 0.80526088
[145] 0.80526088 0.80009895 0.80009895 0.80009895 0.80009895 0.80009895
[151] 0.79480029 0.78950162 0.78950162 0.78950162 0.78413086 0.78413086
[157] 0.78413086 0.78413086 0.77864743 0.77864743 0.77864743 0.77308566
[163] 0.77308566 0.76748359 0.76188152 0.76188152 0.76188152 0.76188152
[169] 0.75615309 0.75615309 0.75615309 0.75615309 0.75615309 0.75615309
[175] 0.75615309 0.75015187 0.74415066 0.74415066 0.73810065 0.73810065
[181] 0.73200065 0.72590064 0.71980063 0.71980063 0.71980063 0.71980063
[187] 0.71980063 0.71348659 0.71348659 0.71348659 0.71348659 0.71348659
[193] 0.70694085 0.70039510 0.69384935 0.68730360 0.68075785 0.67421210
[199] 0.67421210 0.67421210 0.67421210 0.66746998 0.66072786 0.66072786
[205] 0.66072786 0.66072786 0.65377283 0.65377283 0.65377283 0.65377283
[211] 0.64658851 0.64658851 0.64658851 0.64658851 0.64658851 0.64658851
[217] 0.64658851 0.64658851 0.64658851 0.64658851 0.64658851 0.64658851
[223] 0.63840385 0.63840385 0.63840385 0.63000380 0.62160375 0.61320370
[229] 0.61320370 0.60468698 0.60468698 0.59604859 0.58741021 0.58741021
[235] 0.58741021 0.58741021 0.57837313 0.57837313 0.56919260 0.56919260
[241] 0.56919260 0.56919260 0.56919260 0.56919260 0.56919260 0.55902845
[247] 0.55902845 0.54867607 0.54867607 0.53812461 0.53812461 0.53812461
[253] 0.52714247 0.52714247 0.51592667 0.50471088 0.50471088 0.49324018
[259] 0.49324018 0.48149636 0.46975255 0.45800873 0.45800873 0.44595587
[265] 0.44595587 0.43356821 0.42118055 0.42118055 0.40841750 0.40841750
[271] 0.40841750 0.40841750 0.39433414 0.38025078 0.38025078 0.36562575
[277] 0.35100072 0.33637569 0.32175066 0.32175066 0.32175066 0.32175066
[283] 0.30481641 0.30481641 0.28688603 0.26895566 0.26895566 0.24974454
[289] 0.24974454 0.22893249 0.22893249 0.22893249 0.20349555 0.17805861
[295] 0.15262166 0.12718472 0.10174778 0.10174778 0.06783185 0.03391593
> 
> # using the Cox model for the censoring times given X2
> 
> WCox=subjectWeights(Surv(time,status)~X2,data=dat,method="cox")
> WCox

Estimated inverse of the probability of censoring weights (subjectWeights)

Method for estimation:  Cox regression 
Handler function:  function (formula = formula(data), data = parent.frame(), weights, subset, na.action = na.delete, method = c("efron", "breslow", "exact", "model.frame", "model.matrix"), singular.ok = FALSE, robust = FALSE, model = FALSE, x = FALSE, y = FALSE, se.fit = FALSE, linear.predictors = TRUE, residuals = TRUE, nonames = FALSE, eps = 1e-04, init, iter.max = 10, tol = 1e-09, surv = FALSE, time.inc, type = NULL, vartype = NULL, debug = FALSE, ...) 
{
    method <- match.arg(method)
    call <- match.call()
    m <- match.call(expand.dots = FALSE)
    mc <- match(c("formula", "data", "subset", "weights", "na.action"), names(m), 0)
    m <- m[c(1, mc)]
    m$na.action <- na.action
    m$drop.unused.levels <- TRUE
    m[[1]] <- as.name("model.frame")
    if (!inherits(formula, "formula")) {
        if (inherits(formula, "Surv")) {
            xx <- function(x) formula(x)
            formula <- xx(paste(deparse(substitute(formula)), 1, sep = "~"))
        }
        else stop("Invalid formula")
    }
    m$formula <- formula
    nstrata <- 0
    Strata <- NULL
    odb <- .Options$debug
    if (length(odb) && is.logical(odb) && odb) 
        debug <- TRUE
    if (!missing(data) || (length(z <- attr(terms(formula, allowDotAsName = TRUE), "term.labels")) > 0 && any(z != "."))) {
        dul <- .Options$drop.unused.levels
        if (!length(dul) || dul) {
            on.exit(options(drop.unused.levels = dul))
            options(drop.unused.levels = FALSE)
        }
        X <- Design(eval.parent(m))
        atrx <- attributes(X)
        atr <- atrx$Design
        nact <- atrx$na.action
        sformula <- atrx$sformula
        mmcolnames <- atr$mmcolnames
        if (method == "model.frame") 
            return(X)
        Terms <- if (missing(data)) 
            terms(sformula, specials = c("strat", "strata"))
        else terms(sformula, specials = c("strat", "strata"), data = data)
        asm <- atr$assume.code
        name <- atr$name
        specials <- attr(Terms, "specials")
        if (length(specials$strata)) 
            stop("cph supports strat(), not strata()")
        stra <- specials$strat
        cluster <- attr(X, "cluster")
        if (length(cluster)) {
            if (missing(robust)) 
                robust <- TRUE
            attr(X, "cluster") <- NULL
        }
        Terms.ns <- Terms
        if (length(stra)) {
            temp <- untangle.specials(Terms.ns, "strat", 1)
            Terms.ns <- Terms.ns[-temp$terms]
            Strata <- list()
            strataname <- attr(Terms, "term.labels")[stra - 1]
            j <- 0
            for (i in (1:length(asm))[asm == 8]) {
                nstrata <- nstrata + 1
                xi <- X[[i + 1]]
                levels(xi) <- paste(name[i], "=", levels(xi), sep = "")
                Strata[[nstrata]] <- xi
            }
            Strata <- interaction(as.data.frame(Strata), drop = TRUE)
        }
        xpres <- length(asm) && any(asm != 8)
        Y <- model.extract(X, "response")
        if (!inherits(Y, "Surv")) 
            stop("response variable should be a Surv object")
        n <- nrow(Y)
        weights <- model.extract(X, "weights")
        offset <- attr(X, "offset")
        if (!xpres) {
            X <- matrix(nrow = 0, ncol = 0)
            assign <- NULL
        }
        else {
            X <- model.matrix(sformula, X)
            alt <- attr(mmcolnames, "alt")
            if (debug) {
                prn(sformula)
                print(cbind(`colnames(X)` = colnames(X)[-1], mmcolnames = mmcolnames, `Design colnames` = atr$colnames, alt = alt))
            }
            if (!all(mmcolnames %in% colnames(X)) && length(alt)) 
                mmcolnames <- alt
            X <- X[, mmcolnames, drop = FALSE]
            assign <- attr(X, "assign")
            assign[[1]] <- NULL
        }
        nullmod <- FALSE
    }
    else {
        X <- NULL
        Terms <- terms(formula)
        yy <- attr(terms(formula), "variables")[1]
        Y <- eval(yy, data)
        if (!inherits(Y, "Surv")) 
            stop("response variable should be a Surv object")
        Y <- Y[!is.na(Y)]
        assign <- NULL
        xpres <- FALSE
        nullmod <- TRUE
        nact <- NULL
    }
    ny <- ncol(Y)
    maxtime <- max(Y[, ny - 1])
    rnam <- if (!nonames) 
        dimnames(Y)[[1]]
    if (xpres) 
        dimnames(X) <- list(rnam, atr$colnames)
    if (method == "model.matrix") 
        return(X)
    time.units <- units(Y)
    if (!length(time.units) || time.units == "") 
        time.units <- "Day"
    if (missing(time.inc)) {
        time.inc <- switch(time.units, Day = 30, Month = 1, Year = 1, maxtime/10)
        if (time.inc >= maxtime | maxtime/time.inc > 25) 
            time.inc <- max(pretty(c(0, maxtime)))/10
    }
    ytype <- attr(Y, "type")
    if (nullmod) 
        f <- NULL
    else {
        fitter <- if (method == "breslow" || method == "efron") {
            if (ytype == "right") 
                coxph.fit
            else agreg.fit
        }
        else if (method == "exact") {
            if (ytype == "right") 
                getFromNamespace("coxexact.fit", "survival")
            else agexact.fit
        }
        else stop(paste("Unknown method", method))
        if (missing(init)) 
            init <- NULL
        f <- fitter(X, Y, strata = Strata, offset = offset, weights = weights, init = init, method = method, rownames = rnam, control = coxph.control(eps = eps, toler.chol = tol, toler.inf = 1, iter.max = iter.max))
    }
    if (is.character(f)) {
        cat("Failure in cph:\n", f, "\n")
        return(structure(list(fail = TRUE), class = "cph"))
    }
    else {
        if (length(f$coefficients) && any(is.na(f$coefficients))) {
            vars <- names(f$coefficients)[is.na(f$coefficients)]
            msg <- paste("X matrix deemed to be singular; variable", paste(vars, collapse = " "))
            if (singular.ok) 
                warning(msg)
            else {
                cat(msg, "\n")
                return(structure(list(fail = TRUE), class = "cph"))
            }
        }
    }
    f$terms <- Terms
    f$sformula <- sformula
    f$mmcolnames <- mmcolnames
    if (robust) {
        f$naive.var <- f$var
        if (!length(cluster)) 
            cluster <- FALSE
        fit2 <- c(f, list(x = X, y = Y, weights = weights, method = method))
        if (length(stra)) 
            fit2$strata <- Strata
        r <- getS3method("residuals", "coxph")(fit2, type = "dfbeta", collapse = cluster, weighted = TRUE)
        f$var <- t(r) %*% r
    }
    nvar <- length(f$coefficients)
    ev <- factor(Y[, ny], levels = 0:1, labels = c("No Event", "Event"))
    n.table <- {
        if (!length(Strata)) 
            table(ev, dnn = "Status")
        else table(Strata, ev, dnn = c("Stratum", "Status"))
    }
    f$n <- n.table
    nevent <- sum(Y[, ny])
    if (xpres) {
        logtest <- -2 * (f$loglik[1] - f$loglik[2])
        R2.max <- 1 - exp(2 * f$loglik[1]/n)
        R2 <- (1 - exp(-logtest/n))/R2.max
        P <- 1 - pchisq(logtest, nvar)
        gindex <- GiniMd(f$linear.predictors)
        dxy <- dxy.cens(f$linear.predictors, Y, type = "hazard")["Dxy"]
        stats <- c(n, nevent, logtest, nvar, P, f$score, 1 - pchisq(f$score, nvar), R2, dxy, gindex, exp(gindex))
        names(stats) <- c("Obs", "Events", "Model L.R.", "d.f.", "P", "Score", "Score P", "R2", "Dxy", "g", "gr")
    }
    else {
        stats <- c(n, nevent)
        names(stats) <- c("Obs", "Events")
    }
    f$method <- NULL
    if (xpres) 
        dimnames(f$var) <- list(atr$colnames, atr$colnames)
    f <- c(f, list(call = call, Design = atr, assign = DesignAssign(atr, 0, atrx$terms), na.action = nact, fail = FALSE, non.slopes = 0, stats = stats, method = method, maxtime = maxtime, time.inc = time.inc, units = time.units))
    if (xpres) {
        f$center <- sum(f$means * f$coefficients)
        f$scale.pred <- c("log Relative Hazard", "Hazard Ratio")
        attr(f$linear.predictors, "strata") <- Strata
        names(f$linear.predictors) <- rnam
        if (se.fit) {
            XX <- X - rep(f$means, rep.int(n, nvar))
            se.fit <- drop(((XX %*% f$var) * XX) %*% rep(1, ncol(XX)))^0.5
            names(se.fit) <- rnam
            f$se.fit <- se.fit
        }
    }
    if (model) 
        f$model <- m
    if (is.character(surv) || surv) {
        if (length(Strata)) {
            iStrata <- as.character(Strata)
            slev <- levels(Strata)
            nstr <- length(slev)
        }
        else nstr <- 1
        srv <- NULL
        tim <- NULL
        s.e. <- NULL
        timepts <- seq(0, maxtime, by = time.inc)
        s.sum <- array(double(1), c(length(timepts), nstr, 3), list(format(timepts), paste("Stratum", 1:nstr), c("Survival", "n.risk", "std.err")))
        g <- list(n = sum(f$n), coefficients = f$coefficients, linear.predictors = f$linear.predictors, method = f$method, type = type, means = f$means, var = f$var, x = X, y = Y, strata = Strata, offset = offset, weights = weights, terms = Terms, call = call)
        g <- survfit.cph(g, se.fit = is.character(surv) || surv, type = type, vartype = vartype, conf.type = "log")
        strt <- if (nstr > 1) 
            rep(names(g$strata), g$strata)
        for (k in 1:nstr) {
            j <- if (nstr == 1) 
                TRUE
            else strt == slev[k]
            yy <- Y[if (nstr == 1) 
                TRUE
            else iStrata == slev[k], ny - 1]
            maxt <- max(yy)
            tt <- c(0, g$time[j])
            su <- c(1, g$surv[j])
            se <- c(NA, g$std.err[j])
            if (maxt > tt[length(tt)]) {
                tt <- c(tt, maxt)
                su <- c(su, su[length(su)])
                se <- c(se, NA)
            }
            kk <- 0
            for (tp in timepts) {
                kk <- kk + 1
                t.choice <- max((1:length(tt))[tt <= tp + 1e-06])
                if (tp > max(tt) + 1e-06 & su[length(su)] > 0) {
                  Su <- NA
                  Se <- NA
                }
                else {
                  Su <- su[t.choice]
                  Se <- se[t.choice]
                }
                n.risk <- sum(yy >= tp)
                s.sum[kk, k, 1:3] <- c(Su, n.risk, Se)
            }
            if (!is.character(surv)) {
                if (nstr == 1) {
                  tim <- tt
                  srv <- su
                  s.e. <- se
                }
                else {
                  tim <- c(tim, list(tt))
                  srv <- c(srv, list(su))
                  s.e. <- c(s.e., list(se))
                }
            }
        }
        if (is.character(surv)) 
            f$surv.summary <- s.sum
        else {
            if (nstr > 1) {
                names(srv) <- names(tim) <- names(s.e.) <- levels(Strata)
            }
            f <- c(f, list(time = tim, surv = srv, std.err = s.e., surv.summary = s.sum))
        }
    }
    f$strata <- Strata
    if (x) 
        f$x <- X
    if (y) 
        f$y <- Y
    f$weights <- weights
    f$offset <- offset
    if (!linear.predictors) 
        f$linear.predictors <- NULL
    if (!residuals) 
        f$residuals <- NULL
    class(f) <- c("cph", "rms", "coxph")
    f
}() 

Summary of the weights  G(T_i-|X_i) :

   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
 0.0393  0.6206  0.7942  0.7388  0.9160  1.0000 
> plot(WCox$weights,WKM$weights)
> 
> # using the stratified Kaplan-Meier for the censoring times given X2
> 
> WKM2 <- subjectWeights(Surv(time,status)~X2,data=dat,method="nonpar")
> plot(WKM2$fit,add=FALSE)
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:survival’, ‘package:prodlim’

> nameEx("subsetIndex")
> ### * subsetIndex
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: subsetIndex
> ### Title: Extract Specific Elements From An Object
> ### Aliases: subsetIndex subsetIndex.default subsetIndex.matrix
> 
> ### ** Examples
> 
> M <- matrix(rnorm(50),5,10)
> subsetIndex(M, index = c(0,0,1), default = 0)
     [,1] [,2]       [,3]
[1,]    0    0 -0.6264538
[2,]    0    0  0.1836433
[3,]    0    0 -0.8356286
[4,]    0    0  1.5952808
[5,]    0    0  0.3295078
> subsetIndex(M, index = c(0,2,3,NA), default = 0)
     [,1]       [,2]       [,3] [,4]
[1,]    0 -0.8204684  1.5117812   NA
[2,]    0  0.4874291  0.3898432   NA
[3,]    0  0.7383247 -0.6212406   NA
[4,]    0  0.5757814 -2.2146999   NA
[5,]    0 -0.3053884  1.1249309   NA
> subsetIndex(M, index = c(0,NA,2,3,NA), default = 0)
     [,1] [,2]       [,3]       [,4] [,5]
[1,]    0   NA -0.8204684  1.5117812   NA
[2,]    0   NA  0.4874291  0.3898432   NA
[3,]    0   NA  0.7383247 -0.6212406   NA
[4,]    0   NA  0.5757814 -2.2146999   NA
[5,]    0   NA -0.3053884  1.1249309   NA
> 
> C <- 1:10
> subsetIndex(C, index = c(0,0,1,5,NA), default = 0)
[1]  0  0  1  5 NA
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  17.567 1.081 18.99 0.001 0.004 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
